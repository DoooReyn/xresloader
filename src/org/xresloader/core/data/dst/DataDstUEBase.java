package org.xresloader.core.data.dst;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.regex.Pattern;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;
import org.xresloader.core.ProgramOptions;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstChildrenNode;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstFieldExt;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstMessageExt;
import org.xresloader.core.data.dst.DataDstWriterNode.JAVA_TYPE;
import org.xresloader.core.data.err.ConvException;
import org.xresloader.core.data.src.DataContainer;
import org.xresloader.core.data.src.DataSrcImpl;
import org.xresloader.core.engine.IdentifyEngine;
import org.xresloader.core.scheme.SchemeConf;

/**
 * Created by owentou on 2019/04/08.
 */
public abstract class DataDstUEBase extends DataDstImpl {
    static private Pattern fileToClassMatcher = Pattern.compile("[" + Pattern.quote(".-()_") + "\\s]");
    static private String codeHeaderPrefixGuard = String.join("\r\n", "// This file is generated by xresloader, please don't edit it.", "", "#pragma once", "");
    static private String codeHeaderPrefix1 =
            String.join("\r\n", "", "#include \"CoreMinimal.h\"", "#include \"UObject/ConstructorHelpers.h\"", "#include \"Engine/DataTable.h\"", "");
    static private String codeHeaderIncludeGenerated = "#include \"%s.generated.h\"";
    static private String codeHeaderPrefix2 = String.join("\r\n", "", "", "", "USTRUCT(BlueprintType)", "");
    static private String codeHeaderClassName = "struct F%s : public FTableRowBase";
    static private String codeHeaderPrefix3 = String.join("\r\n", "", "{", "    GENERATED_USTRUCT_BODY()", "", "    // Start of fields");
    static private String codeHeaderSuffix = "\r\n};";
    static private String codeSourceInclude = "#include \"%s.h\"";
    static private String ueImportFile = "UnreaImportSettings.json";
    private Charset encodingCache = null;
    private String headerFieldUProperty = null;
    private String headerFieldUFunction = null;

    public enum NAME_TYPE {
        LONG, STRING, DOUBLE
    }

    public class UEDataRowRule {
        public String helper = null;
        public String description = null;
        public NAME_TYPE nameType = NAME_TYPE.LONG;
        public ArrayList<DataDstWriterNodeWrapper> keyFields = null;
        public ArrayList<DataDstWriterNodeWrapper> valueFields = null;
    }

    @Override
    public boolean init() {
        encodingCache = null;
        headerFieldUProperty = null;
        return true;
    }

    /**
     * @return 协议处理器名字
     */
    public String name() {
        return "ue";
    }

    static public class UECodeInfo {
        public String header = null;
        public String source = null;
        public String outputFile = null;
        public String outputDir = null;
        public String headerDir = null;
        public String sourceDir = null;
        public String includeDir = null;
        public String packageName = null;
        public String clazzName = null;
        public String baseName = null;
        public String category = null;
        public String destinationPath = null;

        public boolean hasGeneratedCode = false;
        public ArrayList<UECodeInfo> dependencies = null;
        public DataDstWriterNode desc = null;

        UECodeInfo makeDependence(DataDstWriterNode desc) {
            // 这里必须和build_data一样
            String baseName = null;
            if (desc.getPackageName() == null || desc.getPackageName().isEmpty()) {
                baseName = desc.getMessageName();
            } else {
                baseName = desc.getPackageName() + "_" + desc.getMessageName();
            }

            UECodeInfo ret = getCodeCache(baseName);
            if (ret != null) {
                if (null == dependencies) {
                    dependencies = new ArrayList<UECodeInfo>();
                }
                dependencies.add(ret);

                ret.desc = desc;
                return ret;
            }

            ret = new UECodeInfo();
            ret.desc = desc;
            ret.outputFile = this.outputFile;
            ret.outputDir = this.outputDir;
            ret.headerDir = this.headerDir;
            ret.sourceDir = this.sourceDir;
            ret.includeDir = this.includeDir;
            ret.category = this.category;
            ret.destinationPath = this.destinationPath;
            ret.packageName = packageName;

            ret.initClazzName(baseName);

            if (null == dependencies) {
                dependencies = new ArrayList<UECodeInfo>();
            }
            dependencies.add(ret);

            setCodeCache(baseName, ret);
            return ret;
        }

        void initClazzName(String baseName) {
            this.baseName = baseName;
            this.clazzName = getIdentName(this.baseName);
            this.header = this.headerDir + File.separator + this.clazzName + ".h";
            this.source = this.sourceDir + File.separator + this.clazzName + ".cpp";
        }
    }

    static private HashMap<String, UECodeInfo> globalCodeCache = new HashMap<String, UECodeInfo>();

    static UECodeInfo getCodeCache(String clazzName) {
        if (clazzName == null || clazzName.isEmpty()) {
            clazzName = "";
        } else {
            clazzName = getIdentName(clazzName);
        }

        return globalCodeCache.getOrDefault(clazzName, null);
    }

    static void setCodeCache(String clazzName, UECodeInfo code) {
        if (clazzName == null || clazzName.isEmpty()) {
            clazzName = "";
        } else {
            clazzName = getIdentName(clazzName);
        }

        globalCodeCache.put(clazzName, code);
    }

    static public class DataDstWriterNodeWrapper implements Comparable<DataDstWriterNodeWrapper> {
        public String varName = null;
        public ArrayList<DataDstWriterNode> descs = new ArrayList<DataDstWriterNode>();
        public boolean isGenerated = false;
        public boolean isList = false;
        public ArrayList<DataDstWriterNodeWrapper> children = null;

        public DataDstWriterNode GetWriterNode(int i) {
            if (i >= descs.size()) {
                return null;
            }

            return descs.get(i);
        }

        public JAVA_TYPE getJavaType() {
            DataDstWriterNode n = GetWriterNode(0);
            if (n == null) {
                return JAVA_TYPE.STRING;
            }

            return n.getType();
        }

        static private DataDstMessageExt emptyMsgExt = new DataDstMessageExt();

        public DataDstMessageExt getMessageExtension() {
            DataDstWriterNode n = GetWriterNode(0);
            if (n == null) {
                return emptyMsgExt;
            }

            return n.getMessageExtension();
        }

        static private DataDstFieldExt emptyFieldExt = new DataDstFieldExt();

        public DataDstFieldExt getFieldExtension() {
            DataDstWriterNode n = GetWriterNode(0);
            if (n == null) {
                return emptyFieldExt;
            }

            return n.getFieldExtension();
        }

        @Override
        public int compareTo(DataDstWriterNodeWrapper r) {
            for (int i = 0; i < descs.size() && i < r.descs.size(); ++i) {
                DataDstWriterNode ld = GetWriterNode(i);
                DataDstWriterNode rd = r.GetWriterNode(i);
                int lv = 0;
                if (ld != null && ld.identify != null) {
                    lv = ld.identify.index;
                }
                int rv = 0;
                if (rd != null && rd.identify != null) {
                    rv = rd.identify.index;
                }

                if (lv != rv) {
                    return lv - rv;
                }
            }

            return descs.size() - r.descs.size();
        }
    }

    static public String getIdentName(String in) {
        String[] segs = fileToClassMatcher.split(in);
        if (SchemeConf.getInstance().getUECSVOptions().enableCaseConvert) {
            for (int i = 0; i < segs.length; ++i) {
                if (!segs[i].isEmpty() && Character.isLowerCase(segs[i].charAt(0))) {
                    segs[i] = Character.toUpperCase(segs[i].charAt(0)) + segs[i].substring(1);
                }
            }
            return String.join("", segs);
        } else {
            return String.join("_", segs);
        }
    }

    public UECodeInfo getCodeInfo(String outputFile, String baseName, DataDstWriterNode desc) throws IOException {
        File ofd = new File(outputFile);
        if (baseName == null || baseName.isEmpty()) {
            String fileName = ofd.getName();
            int lastDot = fileName.lastIndexOf('.');
            if (lastDot < 0) {
                baseName = fileName;
            } else {
                baseName = fileName.substring(0, lastDot);
            }
        }

        UECodeInfo ret = getCodeCache(baseName);
        if (ret != null) {
            ret.desc = desc;
            return ret;
        }

        ret = new UECodeInfo();
        ret.desc = desc;
        ret.outputFile = ofd.getCanonicalFile().getAbsolutePath();
        ret.outputDir = ofd.getParentFile().getCanonicalFile().getAbsolutePath();
        // redirect header directory and source directory
        String codeOutputDir = SchemeConf.getInstance().getUECSVOptions().codeOutputDir;
        if (codeOutputDir.isEmpty()) {
            codeOutputDir = (new File(ProgramOptions.getInstance().outputDirectory)).getCanonicalFile().getAbsolutePath();
        }
        if (SchemeConf.getInstance().getUECSVOptions().category.isEmpty()) {
            ret.category = "DataTable";
        } else {
            ret.category = SchemeConf.getInstance().getUECSVOptions().category;
        }
        if (!SchemeConf.getInstance().getUECSVOptions().codeOutputPublicDir.isEmpty()) {
            String pubDir = SchemeConf.getInstance().getUECSVOptions().codeOutputPublicDir;
            ret.headerDir = codeOutputDir + File.separator + pubDir;
            if (pubDir.charAt(0) == '/' || pubDir.charAt(0) == '\\') {
                pubDir = pubDir.substring(1);
            }
            if (pubDir.substring(0, 7).equalsIgnoreCase("Public/")) {
                ret.includeDir = pubDir.substring(7).replace('\\', '/');
            } else {
                ret.includeDir = pubDir.replace('\\', '/');
            }
            if (!ret.includeDir.isEmpty() && !ret.includeDir.endsWith("/")) {
                ret.includeDir = ret.includeDir + "/";
            }
        } else {
            ret.headerDir = codeOutputDir;
            ret.includeDir = "";
        }
        if (!SchemeConf.getInstance().getUECSVOptions().codeOutputPrivateDir.isEmpty()) {
            ret.sourceDir = codeOutputDir + File.separator + SchemeConf.getInstance().getUECSVOptions().codeOutputPrivateDir;
        } else {
            ret.sourceDir = codeOutputDir;
        }

        ret.initClazzName(baseName);
        ret.destinationPath = "DataTable";
        if (ret.includeDir.length() > 1) {
            ret.destinationPath = String.format("%s", ret.includeDir.substring(0, ret.includeDir.length() - 1));
        }

        setCodeCache(baseName, ret);
        return ret;
    }

    public void writeImportSettings(UECodeInfo code) {
        File importFile = new File(code.outputDir + File.separator + ueImportFile);
        if (!importFile.getParentFile().exists()) {
            importFile.getParentFile().mkdirs();
        }

        JSONObject importObj;
        JSONArray groupObj;

        if (importFile.exists()) {
            try {
                importObj = new JSONObject(new JSONTokener(new FileInputStream(importFile)));
            } catch (JSONException | FileNotFoundException e) {
                importObj = new JSONObject();
                ProgramOptions.getLoger().error("Read json from %s failed, %s", importFile.getAbsolutePath(), e.getMessage());
            }
        } else {
            importObj = new JSONObject();
        }

        try {
            if (importObj.has("ImportGroups")) {
                groupObj = importObj.getJSONArray("ImportGroups");
            } else {
                groupObj = new JSONArray();
                importObj.put("ImportGroups", groupObj);
            }

            JSONObject selectedItem = null;
            for (int i = 0; i < groupObj.length(); ++i) {
                JSONObject item = groupObj.getJSONObject(i);
                if (item.has("ImportSettings")) {
                    if (item.getJSONObject("ImportSettings").optString("ImportRowStruct").equals(code.clazzName)) {
                        selectedItem = item;
                        break;
                    }
                }
            }

            if (null == selectedItem) {
                selectedItem = new JSONObject();
                groupObj.put(selectedItem);
            }

            selectedItem.put("GroupName", code.category);

            JSONArray dataFileList = new JSONArray();
            dataFileList.put(code.outputFile);
            selectedItem.put("Filenames", dataFileList);
            selectedItem.put("DestinationPath", code.destinationPath);
            selectedItem.put("bReplaceExisting", "true");
            selectedItem.put("bSkipReadOnly", "true");
            selectedItem.put("FactoryName", "ReimportDataTableFactory");

            JSONObject importSetting = null;
            if (selectedItem.has("ImportSettings")) {
                importSetting = selectedItem.getJSONObject("ImportSettings");
            } else {
                importSetting = new JSONObject();
                selectedItem.put("ImportSettings", importSetting);
            }

            importSetting.put("ImportRowStruct", code.clazzName);
            importSetting.put("ImportType", "ECSV_DataTable");

            FileOutputStream fos = new FileOutputStream(importFile, false);
            fos.write(dumpString(importObj.toString(4)));
            fos.close();
        } catch (Exception e) {
            ProgramOptions.getLoger().error("Write json to %s failed, %s", importFile.getAbsolutePath(), e.getMessage());
        }
    }

    private byte[] dumpString(String in) {
        if (null != encodingCache) {
            return in.getBytes(encodingCache);
        }

        // 带编码的输出
        String encoding = SchemeConf.getInstance().getKey().getEncoding();
        if (null == encoding || encoding.isEmpty())
            return in.toString().getBytes();

        encodingCache = Charset.forName(encoding);
        return in.getBytes(encodingCache);
    }

    public FileOutputStream createCodeHeaderFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.header);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.header, false);
        fos.write(dumpString(codeHeaderPrefixGuard));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
        }
        fos.write(dumpString(codeHeaderPrefix1));

        // include all dependicies
        for (UECodeInfo depCodeInfo : code.dependencies) {
            fos.write(dumpString(String.format(codeSourceInclude, depCodeInfo.includeDir + depCodeInfo.clazzName)));
        }

        fos.write(dumpString(String.format(codeHeaderIncludeGenerated, code.clazzName)));
        fos.write(dumpString(codeHeaderPrefix2));
        fos.write(dumpString(String.format(codeHeaderClassName, code.clazzName)));
        fos.write(dumpString(codeHeaderPrefix3));

        return fos;
    }

    public FileOutputStream createCodeSourceFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.source);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.source, false);
        fos.write(dumpString("// This file is generated by xresloader, please don't edit it.\r\n\r\n"));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
            fos.write(dumpString("\r\n"));
        }

        fos.write(dumpString(String.format(codeSourceInclude, code.includeDir + code.clazzName)));

        return fos;
    }

    @Override
    public final byte[] build(DataDstImpl compiler) throws ConvException {
        // DataDstJava.DataDstObject data_obj = build_data(compiler);
        Object buildObj = null;

        try {
            buildObj = buildForUEOnInit();

            build_data(buildObj, compiler);
        } catch (IOException e) {
            throw new ConvException(String.format("build data for %s failed. msg: %s", name(), e.getMessage()));
        }

        return buildForUEOnFinal(buildObj);
    }

    abstract protected boolean isRecursiveEnabled();

    abstract protected Object buildForUEOnInit() throws IOException;

    abstract protected byte[] buildForUEOnFinal(Object buildObj);

    abstract protected void buildForUEOnPrintHeader(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule) throws IOException;

    abstract protected void buildForUEOnPrintRecord(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule) throws IOException;

    private UEDataRowRule rebuildCodeRule(UECodeInfo codeInfo) throws ConvException {
        if (null == codeInfo.desc) {
            return null;
        }

        // 生成描述集,CSV必须固定化描述集，可能需要把字段平铺开来。
        ArrayList<DataDstWriterNodeWrapper> expandedDesc = expandDescription(null, codeInfo.desc, "", 0);

        if (expandedDesc == null || expandedDesc.isEmpty()) {
            return null;
        }

        // ======================================================================================================
        UEDataRowRule rule = splitDataRowDesc(expandedDesc);
        rule.helper = codeInfo.desc.getMessageExtension().mutableUE().helper;
        rule.description = codeInfo.desc.getMessageExtension().description;
        // ======================================================================================================

        return rule;

    }

    protected final void build_data(Object buildObj, DataDstImpl compiler) throws ConvException, IOException {
        while (DataSrcImpl.getOurInstance().next_table()) {
            // 生成描述集
            DataDstWriterNode desc = compiler.compile();

            // 这里规则必须和makeDependence(desc)一样
            String originClazzName;
            if (desc.getPackageName() == null || desc.getPackageName().isEmpty()) {
                originClazzName = desc.getMessageName();
            } else {
                originClazzName = desc.getPackageName() + "_" + desc.getMessageName();
            }
            UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), originClazzName, desc);
            UEDataRowRule rule = rebuildCodeRule(codeInfo);

            if (rule == null) {
                continue;
            }

            // 输出header
            ArrayList<Object> row_data = new ArrayList<Object>();
            row_data.ensureCapacity(rule.keyFields.size() + rule.valueFields.size());
            for (int i = 0; i < rule.keyFields.size(); ++i) {
                row_data.add(rule.keyFields.get(i).varName);
            }
            for (int i = 0; i < rule.valueFields.size(); ++i) {
                row_data.add(rule.valueFields.get(i).varName);
            }
            buildForUEOnPrintHeader(buildObj, row_data, rule);

            // 输出数据
            while (DataSrcImpl.getOurInstance().next_row()) {
                row_data = new ArrayList<Object>();
                row_data.ensureCapacity(rule.keyFields.size() + rule.valueFields.size());

                // 先用特殊规则导入Name字段,Name字段可能是合成字段
                row_data.add(pickNameField(rule));
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    row_data.add(pickValueField(rule.keyFields.get(i).GetWriterNode(0)));
                }
                for (int i = 0; i < rule.valueFields.size(); ++i) {
                    row_data.add(pickValueField(rule.valueFields.get(i).GetWriterNode(0)));
                }
                buildForUEOnPrintRecord(buildObj, row_data, rule);
            }

            // 加载代码
            writeCodeFiles(rule, codeInfo);

            // 写出导出文件
            writeImportSettings(codeInfo);
        }
    }

    private void writeCodeFiles(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException, ConvException {
        if (null == codeInfo || codeInfo.hasGeneratedCode || null == rule) {
            return;
        }
        codeInfo.hasGeneratedCode = true;
        codeInfo.dependencies.clear();

        // 递归写出依赖的数据结构
        if (null != codeInfo.desc && codeInfo.desc.getChildren() != null) {
            for (HashMap.Entry<String, DataDstChildrenNode> child : codeInfo.desc.getChildren().entrySet()) {
                if (child.getValue().nodes.isEmpty()) {
                    continue;
                }

                if (child.getValue().nodes.get(0).getType() == JAVA_TYPE.MESSAGE) {
                    UECodeInfo depCodeInfo = codeInfo.makeDependence(child.getValue().nodes.get(0));
                    if (null == depCodeInfo || depCodeInfo.hasGeneratedCode) {
                        continue;
                    }

                    UEDataRowRule depRule = rebuildCodeRule(depCodeInfo);
                    writeCodeFiles(depRule, depCodeInfo);
                }
            }
        }

        // 加载代码
        writeCodeHeaderFile(rule, codeInfo);
        writeCodeSourceFile(rule, codeInfo);
    }

    private Object pickNameField(UEDataRowRule rule) throws ConvException {
        // 如果是直接采用原始字段则直接返回原始字段数据
        if (null != rule.keyFields.get(0).descs && !rule.keyFields.get(0).descs.isEmpty()) {
            return pickValueField(rule.valueFields.get(0).GetWriterNode(0));
        }

        switch (rule.nameType) {
            case LONG: {
                long ret = 0;
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
                    DataDstWriterNode desc = wrapper.GetWriterNode(0);
                    Object val = pickValueField(desc);
                    if (val instanceof Number) {
                        ret = ret + wrapper.getFieldExtension().mutableUE().keyTag * ((Number) val).longValue();
                    } else {
                        ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                                * Long.valueOf(pickValueField(rule.keyFields.get(i).GetWriterNode(0)).toString());
                    }
                }

                return ret;
            }
            case DOUBLE: {
                double ret = 0.0;
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
                    DataDstWriterNode desc = wrapper.GetWriterNode(0);
                    Object val = pickValueField(desc);
                    if (val instanceof Number) {
                        ret = ret + wrapper.getFieldExtension().mutableUE().keyTag * ((Number) val).doubleValue();
                    } else {
                        ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                                * Double.valueOf(pickValueField(rule.keyFields.get(i).GetWriterNode(0)).toString());
                    }
                }

                return ret;
            }
            case STRING: {
                ArrayList<String> ls = new ArrayList<String>();
                ls.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    ls.add(pickValueField(rule.keyFields.get(i).GetWriterNode(0)).toString());
                }

                return String.join("", ls);
            }
            default:
                return 0;
        }
    }

    private Object pickValueField(DataDstWriterNode desc) throws ConvException {
        if (null == desc.identify || desc.getType() == DataDstWriterNode.JAVA_TYPE.MESSAGE) {
            return false;
        }

        switch (desc.getType()) {
            case INT: {
                DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
                if (null != ret && ret.valid) {
                    return ret.value.intValue();
                }
                break;
            }

            case LONG: {
                DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
                if (null != ret && ret.valid) {
                    return ret.value.longValue();
                }
                break;
            }

            case FLOAT: {
                DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
                if (null != ret && ret.valid) {
                    return ret.value.floatValue();
                }
                break;
            }

            case DOUBLE: {
                DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
                if (null != ret && ret.valid) {
                    return ret.value.doubleValue();
                }
                break;
            }

            case BOOLEAN: {
                DataContainer<Boolean> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, false);
                if (null != ret && ret.valid) {
                    return ret.value.booleanValue();
                }
                break;
            }

            case STRING: {
                DataContainer<String> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
                if (null != ret && ret.valid) {
                    return ret.value;
                }
                break;
            }

            case BYTES: {
                DataContainer<String> res = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
                if (null != res && res.valid) {
                    String encoding = SchemeConf.getInstance().getKey().getEncoding();
                    if (null == encoding || encoding.isEmpty()) {
                        return Base64.getEncoder().encodeToString(res.value.getBytes());
                    } else {
                        return Base64.getEncoder().encodeToString(res.value.getBytes(Charset.forName(encoding)));
                    }
                }
                break;
            }

            case MESSAGE: {
                break;
            }
            default:
                break;
        }

        return null;
    }

    protected ArrayList<DataDstWriterNodeWrapper> expandDescription(ArrayList<DataDstWriterNodeWrapper> descs, DataDstWriterNode desc, String prefix,
            int listCapacity) {
        boolean isLeaf = true;
        ArrayList<DataDstWriterNodeWrapper> children = null;
        switch (desc.getType()) {
            case INT: {
                break;
            }
            case LONG: {
                break;
            }
            case BOOLEAN: {
                break;
            }
            case STRING: {
                break;
            }
            case BYTES: {
                break;
            }
            case FLOAT: {
                break;
            }
            case DOUBLE: {
                break;
            }
            case MESSAGE: {
                boolean isRecursiveMode = isRecursiveEnabled();

                // if it's top message or is not recursive mode
                if (!isRecursiveMode) {
                    isLeaf = false;
                }

                if (descs == null) {
                    descs = new ArrayList<DataDstWriterNodeWrapper>();
                    if (isLeaf) {
                        // 留一个给Name字段
                        descs.ensureCapacity(desc.getChildren().size() + 2);
                    } else {
                        descs.ensureCapacity(Math.max(desc.getChildren().size() * 2, 32));
                    }
                }


                for (HashMap.Entry<String, DataDstChildrenNode> child : desc.getChildren().entrySet()) {
                    String varName = getIdentName(child.getKey());
                    if (isLeaf) {
                        if (child.getValue().innerDesc.isList()) {
                            if (child.getValue().nodes.size() <= 0) {
                                children = new ArrayList<DataDstWriterNodeWrapper>();
                                continue;
                            }

                            DataDstWriterNode child_desc = child.getValue().nodes.get(0);
                            children = expandDescription(children, child_desc, "_" + varName, child.getValue().nodes.size());

                            if (!children.isEmpty()) {
                                continue;
                            }

                            DataDstWriterNodeWrapper lastChild = children.get(children.size() - 1);
                            if (lastChild.descs.isEmpty() || lastChild.GetWriterNode(0) != child_desc) {
                                ProgramOptions.getLoger().error("Add child %s for %s failed.", child.getKey(), desc.getFullName());
                                continue;
                            }

                            // 把剩下的也加进去
                            for (int i = 1; i < child.getValue().nodes.size(); ++i) {
                                lastChild.descs.add(child.getValue().nodes.get(i));
                            }
                        } else if (!child.getValue().nodes.isEmpty()) {
                            children = expandDescription(children, child.getValue().nodes.get(0), "_" + varName, 0);
                        }
                    } else {
                        if (child.getValue().innerDesc.isList()) {
                            for (int i = 0; i < child.getValue().nodes.size(); ++i) {
                                DataDstWriterNode child_desc = child.getValue().nodes.get(i);
                                expandDescription(descs, child_desc, prefix + String.format("_%s_%d", varName, i), 0);
                            }
                        } else if (!child.getValue().nodes.isEmpty()) {
                            expandDescription(descs, child.getValue().nodes.get(0), prefix + "_" + varName, 0);
                        }
                    }
                }

                break;
            }
        }

        if (!isLeaf) {
            return descs;
        }

        if (descs == null) {
            descs = new ArrayList<DataDstWriterNodeWrapper>();
            if (listCapacity > 0) {
                descs.ensureCapacity(listCapacity);
            } else {
                descs.ensureCapacity(2);
            }
        }

        DataDstWriterNodeWrapper res = new DataDstWriterNodeWrapper();
        res.varName = prefix.substring(1);
        res.descs.add(desc);
        res.children = children;
        res.isList = listCapacity > 0;
        descs.add(res);

        return descs;
    }

    /**
     * 和输出格式无关的常量转储功能
     *
     * @param data 常量数据集
     * @return 常量代码
     */
    abstract public String dumpConstForUE(HashMap<String, Object> data, UEDataRowRule rule) throws IOException;

    /**
     * 转储常量数据
     *
     * @return 常量数据,不支持的时候返回空
     * @throws IOException
     */
    public final byte[] dumpConst(HashMap<String, Object> data) throws ConvException, IOException {
        // 加载代码
        UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), null, null);
        DataDstWriterNode ddNode = null;

        // const完整路径都在data里了，不需要额外的包名(可能包含多个包)
        // ======================================================================================================
        ArrayList<DataDstWriterNodeWrapper> expandedDesc = new ArrayList<DataDstWriterNodeWrapper>();
        DataDstWriterNodeWrapper constNameNode = new DataDstWriterNodeWrapper();
        ddNode = DataDstWriterNode.create(null, DataDstWriterNode.getDefaultMessageDescriptor(DataDstWriterNode.JAVA_TYPE.STRING));
        ddNode.identify = IdentifyEngine.n2i("Name", 0);
        constNameNode.descs.add(ddNode);
        constNameNode.varName = getIdentName("Name");
        constNameNode.isGenerated = true;
        constNameNode.isList = false;
        expandedDesc.add(constNameNode);

        DataDstWriterNodeWrapper constValueNode = new DataDstWriterNodeWrapper();
        ddNode = DataDstWriterNode.create(null, DataDstWriterNode.getDefaultMessageDescriptor(DataDstWriterNode.JAVA_TYPE.STRING));
        ddNode.identify = IdentifyEngine.n2i("Value", 1);
        constNameNode.descs.add(ddNode);
        constValueNode.varName = getIdentName("Value");
        constValueNode.isGenerated = true;
        constNameNode.isList = false;
        expandedDesc.add(constValueNode);

        UEDataRowRule constRule = splitDataRowDesc(expandedDesc);
        constRule.helper = "helper";
        constRule.nameType = NAME_TYPE.STRING;
        // ======================================================================================================

        String constCode = dumpConstForUE(data, constRule);

        // 加载代码
        writeCodeFiles(constRule, codeInfo);

        // 写出导出文件
        writeImportSettings(codeInfo);

        // 带编码的输出
        return dumpString(constCode);
    }

    private final String getHeaderFieldUProperty() {
        if (null == headerFieldUProperty) {
            LinkedList<String> ls = new LinkedList<String>();
            if (!SchemeConf.getInstance().getUECSVOptions().editAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUECSVOptions().editAccess);
            }

            if (!SchemeConf.getInstance().getUECSVOptions().category.isEmpty() && !SchemeConf.getInstance().getUECSVOptions().blueprintAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUECSVOptions().blueprintAccess);
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUECSVOptions().category));
            }
            headerFieldUProperty = String.format("    UPROPERTY(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUProperty;
    }

    private final String getHeaderFieldUFunction() {
        if (null == headerFieldUFunction) {
            LinkedList<String> ls = new LinkedList<String>();

            ls.add("BlueprintCallable");
            if (!SchemeConf.getInstance().getUECSVOptions().category.isEmpty()) {
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUECSVOptions().category));
            }
            headerFieldUFunction = String.format("    UFUNCTION(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUFunction;
    }

    private final String getDataRowKeyToNameParamsSpecify(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.descs != null && !nameNode.descs.isEmpty()) {
            String ueTypeName = getUETypeName(nameNode.GetWriterNode(0));
            if (ueTypeName.equalsIgnoreCase("FString")) {
                ueTypeName = "FName";
            }
            return String.format("%s %s", ueTypeName, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s %s", getUETypeName(keyNode.GetWriterNode(0)), keyNode.varName));
        }

        return String.join(", ", params);
    }

    private final String getDataRowKeyToNameParamsPass(UEDataRowRule rule, String prefix) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        if (null == prefix) {
            prefix = "";
        }
        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.descs != null && !nameNode.descs.isEmpty()) {
            return String.format("%s%s", prefix, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s%s", prefix, keyNode.varName));
        }

        return String.join(", ", params);
    }

    /**
     * @see pickNameField
     * @param rule
     * @return
     */
    private final String getDataRowKeyToNameExpression(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (!nameNode.descs.isEmpty()) {
            String ueTypeNameIdent = nameNode.getFieldExtension().mutableUE().ueTypeName;
            if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                return String.format("*%s.ToString()", nameNode.varName);
            }

            switch (rule.nameType) {
                case LONG:
                    return String.format("*FString::Printf(TEXT(\"%%lld\"), static_cast<long long>(%s))", nameNode.varName);
                case DOUBLE:
                    return String.format("*FString::Printf(TEXT(\"%%g\"), static_cast<double>(%s))", nameNode.varName);
                case STRING:
                    return nameNode.varName;
                default:
                    return "/** Error Key Set **/";
            }
        }

        switch (rule.nameType) {
            case LONG: {
                ArrayList<String> params = new ArrayList<String>();
                params.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                    params.add(String.format("static_cast<long long>(%s) * %s", keyNode.varName, keyNode.getFieldExtension().mutableUE().keyTag));
                }
                return String.format("*FString::Printf(TEXT(\"%%lld\"), %s)", String.join(" + ", params));
            }
            case DOUBLE: {
                ArrayList<String> params = new ArrayList<String>();
                params.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                    params.add(String.format("static_cast<double>(%s) * %s", keyNode.varName, keyNode.getFieldExtension().mutableUE().keyTag));
                }
                return String.format("*FString::Printf(TEXT(\"%%g\"), %s)", String.join(" + ", params));
            }
            case STRING: {
                ArrayList<String> paramTypes = new ArrayList<String>();
                ArrayList<String> paramValues = new ArrayList<String>();
                paramTypes.ensureCapacity(rule.keyFields.size());
                paramValues.ensureCapacity(rule.keyFields.size());
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                    String fmt = getUETypeFormat(keyNode.getJavaType());
                    paramTypes.add(fmt);

                    String ueTypeNameIdent = keyNode.getFieldExtension().mutableUE().ueTypeName;
                    if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                        paramValues.add(String.format("*%s.ToString()", keyNode.varName));
                    } else if (fmt.equals("%s")) {
                        paramValues.add("*" + keyNode.varName);
                    } else {
                        paramValues.add(keyNode.varName);
                    }
                }

                return String.format("*FString::Printf(TEXT(\"%s\"), %s)", String.join("", paramTypes), String.join(", ", paramValues));
            }
            default:
                return "/** Error Key Set **/";
        }
    }

    private final void writeCodeHeaderField(FileOutputStream fout, DataDstWriterNodeWrapper nodeWraper, String varName) throws IOException {
        fout.write(dumpString("\r\n"));
        DataDstWriterNode.JAVA_TYPE descType = DataDstWriterNode.JAVA_TYPE.STRING;
        if (null != nodeWraper.descs && !nodeWraper.descs.isEmpty()) {
            descType = nodeWraper.getJavaType();
            if (null != nodeWraper.GetWriterNode(0).identify && null != nodeWraper.getFieldExtension().description) {
                for (String descLine : nodeWraper.getFieldExtension().description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                    fout.write(dumpString(String.format("    // %s\r\n", descLine)));
                }
            }
        }

        if (nodeWraper.isGenerated) {
            fout.write(dumpString(
                    String.format("    /** Field Type: %s, Name: %s. This field is generated for UE Editor compatible. **/\r\n", descType.name(), varName)));
        } else {
            fout.write(dumpString(String.format("    /** Field Type: %s, Name: %s **/\r\n", descType.name(), varName)));
        }

        String ueTypeName = null;
        boolean enable = true;
        switch (descType) {
            case INT:
            case LONG:
            case FLOAT:
            case DOUBLE:
            case BOOLEAN:
                break;
            case STRING: {
                if (varName.equalsIgnoreCase("Name")) {
                    ueTypeName = "FName";
                }
                break;
            }
            case BYTES: {
                if (varName.equalsIgnoreCase("Name")) {
                    ueTypeName = "FName";
                }
                fout.write(dumpString(String.format("    /** Bytes data will be encoded by base64 for %s */\r\n", varName)));
                break;
            }

            case MESSAGE: {
                ueTypeName = getUETypeName(nodeWraper.GetWriterNode(0));
                break;
            }

            default:
                enable = false;
                fout.write(dumpString(String.format("    /** invalid data type %s of UE DataTable for %s */\r\n", descType.name(), varName)));
                ProgramOptions.getLoger().error("invalid data type %s of UE DataTable for %s, should not called here.", descType.name(), varName);
                break;
        }

        if (enable) {
            if (null == ueTypeName) {
                String ueTypeNameIdent = null;
                if (null != nodeWraper.descs && !nodeWraper.descs.isEmpty() && null != nodeWraper.GetWriterNode(0).identify) {
                    ueTypeNameIdent = nodeWraper.getFieldExtension().mutableUE().ueTypeName;
                }
                if (ueTypeNameIdent == null || ueTypeNameIdent.isEmpty()) {
                    if (null != nodeWraper.descs && !nodeWraper.descs.isEmpty()) {
                        ueTypeName = getUETypeName(nodeWraper.GetWriterNode(0));
                    } else {
                        ueTypeName = getUETypeName(null);
                    }
                } else {
                    if (nodeWraper.getFieldExtension().mutableUE().ueTypeIsClass) {
                        ueTypeName = String.format("TSoftClassPtr< %s >", ueTypeNameIdent);
                    } else {
                        ueTypeName = String.format("TSoftObjectPtr< %s >", ueTypeNameIdent);
                    }
                }
            }
            fout.write(dumpString(getHeaderFieldUProperty()));

            if (nodeWraper.isList) {
                fout.write(dumpString(String.format("    TArray< %s > %s;\r\n", ueTypeName, varName)));
            } else {
                fout.write(dumpString(String.format("    %s %s;\r\n", ueTypeName, varName)));
            }
        }
    }

    private final String getUETypeName(DataDstWriterNode desc) {
        if (null == desc) {
            return "FString";
        }

        DataDstWriterNode.JAVA_TYPE type = desc.getType();
        switch (type) {
            case INT:
                return "int32";
            case LONG:
                return "int64";
            case FLOAT:
                return "float";
            case DOUBLE:
                return "double";
            case BOOLEAN:
                return "bool";
            case STRING:
                return "FString";
            case BYTES:
                return "FString";
            case MESSAGE:
                return String.format("F%s", getIdentName(desc.getMessageName()));
            default:
                return "";
        }
    }

    private final String getUETypeDefault(DataDstWriterNodeWrapper wrapper) {
        DataDstWriterNode.JAVA_TYPE descType = wrapper.getJavaType();
        String ueTypeNameIdent = null;

        if (null != wrapper.descs && !wrapper.descs.isEmpty()) {
            DataDstWriterNode dwn = wrapper.GetWriterNode(0);

            if (null != dwn.identify) {
                ueTypeNameIdent = dwn.getFieldExtension().mutableUE().ueTypeName;
            }
        }

        if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
            return "nullptr";
        }

        switch (descType) {
            case INT:
                return "0";
            case LONG:
                return "0";
            case FLOAT:
                return "0";
            case DOUBLE:
                return "0";
            case BOOLEAN:
                return "false";
            case STRING:
                return "TEXT(\"\")";
            case BYTES:
                return "TEXT(\"\")";
            case MESSAGE:
                return "nullptr";
            default:
                return "NULL";
        }
    }

    private final void writeUETypeSetDefaultCode(FileOutputStream sourceFs, String prefix, DataDstWriterNodeWrapper wrapper) throws IOException {
        // if (wrapper.desc != null && wrapper.desc)
        if (wrapper.isList) {
            sourceFs.write(dumpString(String.format("%s.%s.Reset(0);\r\n", prefix, wrapper.varName)));
            return;
        }

        if (wrapper.descs.isEmpty()) {
            return;
        }

        if (wrapper.children != null) {
            for (DataDstWriterNodeWrapper child : wrapper.children) {
                writeUETypeSetDefaultCode(sourceFs, String.format("%s.%s", prefix, wrapper.varName), child);
            }
            return;
        }

        sourceFs.write(dumpString(String.format("%s.%s = %s;\r\n", prefix, wrapper.varName, getUETypeDefault(wrapper))));
    }

    private final String getUETypeFormat(DataDstWriterNode.JAVA_TYPE type) {
        switch (type) {
            case INT:
                return "%d";
            case LONG:
                return "%lld";
            case FLOAT:
                return "%f";
            case DOUBLE:
                return "%llf";
            case BOOLEAN:
                return "%d";
            case STRING:
                return "%s";
            case BYTES:
                return "%s";
            case MESSAGE:
                return "nullptr";
            default:
                return "NULL";
        }
    }

    private final NAME_TYPE getUENameType(DataDstWriterNodeWrapper descWrapper) {
        DataDstWriterNode desc = descWrapper.GetWriterNode(0);
        if (null != desc.identify && null != desc.getFieldExtension().mutableUE().ueTypeName && !desc.getFieldExtension().mutableUE().ueTypeName.isEmpty()) {
            return NAME_TYPE.STRING;
        }

        switch (desc.getType()) {
            case INT:
                return NAME_TYPE.LONG;
            case LONG:
                return NAME_TYPE.LONG;
            case FLOAT:
                return NAME_TYPE.DOUBLE;
            case DOUBLE:
                return NAME_TYPE.DOUBLE;
            case BOOLEAN:
                return NAME_TYPE.LONG;
            case STRING:
                return NAME_TYPE.STRING;
            case BYTES:
                return NAME_TYPE.STRING;
            case MESSAGE:
                return NAME_TYPE.STRING;
            default:
                return NAME_TYPE.LONG;
        }
    }

    private final UEDataRowRule splitDataRowDesc(ArrayList<DataDstWriterNodeWrapper> expandedDesc) throws ConvException {
        UEDataRowRule ret = new UEDataRowRule();
        if (expandedDesc.isEmpty()) {
            return ret;
        }

        expandedDesc.sort(null);

        // UE 要求Key字段名必须是 Name，所以要查找Name的字段，没有的话要生成一个
        int nameIndex = -1;
        for (int i = 0; i < expandedDesc.size(); ++i) {
            DataDstWriterNodeWrapper nw = expandedDesc.get(i);
            if (nw.varName.equalsIgnoreCase("Name")) {
                if (nw.isList) {
                    throw new ConvException("Name field can not be array/list/repeated");
                }
                nameIndex = i;
                break;
            }
        }

        // 如果字段里本来就有，就直接用原始的字段
        if (nameIndex >= 0) {
            ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
            ret.keyFields.add(expandedDesc.get(nameIndex));
            expandedDesc.remove(nameIndex);
            ret.valueFields = expandedDesc;
            ret.nameType = getUENameType(ret.keyFields.get(0));
            return ret;
        }

        // 检查 key_tag，如果找到了，就优先用 key_tag
        DataDstWriterNodeWrapper namedKey = new DataDstWriterNodeWrapper();
        namedKey.varName = "Name";
        namedKey.isGenerated = true;

        ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.keyFields.ensureCapacity(expandedDesc.size());
        ret.keyFields.add(namedKey);

        ret.valueFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.valueFields.ensureCapacity(expandedDesc.size());

        ret.nameType = NAME_TYPE.LONG;
        for (int i = 0; i < expandedDesc.size(); ++i) {
            DataDstWriterNodeWrapper moved = expandedDesc.get(i);
            if (null != moved.descs && !moved.descs.isEmpty() && null != moved.GetWriterNode(0).identify
                    && moved.GetWriterNode(0).getFieldExtension().mutableUE().keyTag > 0) {
                if (moved.isList) {
                    throw new ConvException("Field with key_tag can not be array/list/repeated");
                }
                ret.keyFields.add(moved);
                switch (getUENameType(moved)) {
                    case LONG:
                        break;
                    case DOUBLE:
                        if (ret.nameType == NAME_TYPE.LONG) {
                            ret.nameType = NAME_TYPE.DOUBLE;
                        }
                        break;
                    case STRING:
                        ret.nameType = NAME_TYPE.STRING;
                        break;
                    default:
                        break;
                }
            } else {
                ret.valueFields.add(moved);
            }
        }

        // 如果没有key tag，则使用第一个非repeated字段
        if (ret.keyFields.size() == 1) {
            for (int i = 0; i < ret.valueFields.size(); ++i) {
                DataDstWriterNodeWrapper nw = ret.valueFields.get(i);
                if (!nw.isList) {
                    namedKey.descs = nw.descs;
                    break;
                }
            }
            ret.nameType = getUENameType(namedKey);
        }

        return ret;
    }

    private final void writeCodeHeaderFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        // 加载代码
        FileOutputStream headerFs = createCodeHeaderFileStream(rule, codeInfo);

        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper desc_wraper = rule.keyFields.get(i);
            writeCodeHeaderField(headerFs, desc_wraper, desc_wraper.varName);
        }

        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper desc_wraper = rule.valueFields.get(i);
            writeCodeHeaderField(headerFs, desc_wraper, desc_wraper.varName);
        }

        // 如果开启了嵌套模式，还要补全未使用的字段，因为可能被别处用到
        if (isRecursiveEnabled()) {
            // TODO
        }

        headerFs.write(dumpString(codeHeaderSuffix));

        if (rule.helper == null || rule.helper.isEmpty()) {
            headerFs.close();
            return;
        }

        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        // 辅助代码类定义
        String helperClazzName = getIdentName(codeInfo.clazzName + "_" + rule.helper);
        headerFs.write(dumpString("UCLASS(Blueprintable, BlueprintType)\r\n"));
        headerFs.write(dumpString(String.format("class U%s : public UObject\r\n", helperClazzName)));
        headerFs.write(dumpString("{\r\n"));
        headerFs.write(dumpString("    GENERATED_BODY()\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("public:\r\n"));
        headerFs.write(dumpString(String.format("    U%s();\r\n", helperClazzName)));
        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("    void OnReload();\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(String.format("    static FName GetRowName(%s);\r\n", getDataRowKeyToNameParamsSpecify(rule))));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    FName GetDataRowName(%s) const;\r\n", getDataRowKeyToNameParamsSpecify(rule))));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    FName GetTableRowName(const F%s& TableRow) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    const F%s& GetDataRowByName(const FName& Name, bool& IsValid) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(
                String.format("    const F%s& GetDataRowByKey(%s, bool& IsValid) const;\r\n", codeInfo.clazzName, getDataRowKeyToNameParamsSpecify(rule))));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(
                String.format("    bool ForeachRow(TFunctionRef<void (const FName& Key, const F%s& Value)> Predicate) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString("    UDataTable* GetRawDataTable(bool& IsValid) const;\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(String.format("    static void ClearRow(F%s& TableRow);\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    void ClearDataRow(F%s& TableRow) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("private:\r\n"));
        headerFs.write(dumpString("    TSharedPtr<ConstructorHelpers::FObjectFinder<UDataTable> > Loader;\r\n"));
        headerFs.write(dumpString("    UDataTable* DataTable;\r\n"));
        headerFs.write(dumpString(String.format("    F%s Empty;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("};\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.close();
    }

    private final void writeCodeSourceFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        FileOutputStream sourceFs = createCodeSourceFileStream(rule, codeInfo);

        if (rule.helper == null || rule.helper.isEmpty()) {
            sourceFs.close();
            return;
        }

        String varIsValidName = "IsValid";
        boolean varIsValidCheck = true;
        while (varIsValidCheck) {
            varIsValidCheck = false;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                if (rule.keyFields.get(i).varName.equalsIgnoreCase(varIsValidName)) {
                    varIsValidName = varIsValidName + "DTR";
                    varIsValidCheck = true;
                }
            }
        }

        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        // 辅助代码类实现
        String helperClazzName = getIdentName(codeInfo.clazzName + "_" + rule.helper);
        String helperDestination;
        if (codeInfo.destinationPath.isEmpty()) {
            helperDestination = codeInfo.clazzName;
        } else {
            helperDestination = String.format("%s/%s", codeInfo.destinationPath, codeInfo.clazzName);
        }

        // constructor
        sourceFs.write(dumpString(String.format("U%s::U%s() : Super()\r\n", helperClazzName, helperClazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format(
                "    this->Loader = MakeShareable(new ConstructorHelpers::FObjectFinder<UDataTable>(TEXT(\"DataTable'/Game/%s'\")));\r\n", helperDestination)));
        // 初始化Empty
        sourceFs.write(dumpString(String.format("    U%s::ClearRow(this->Empty);\r\n", helperClazzName)));
        // 初始化事件监听
        sourceFs.write(dumpString("    if (this->Loader && this->Loader->Succeeded())\r\n"));
        sourceFs.write(dumpString("    {\r\n"));
        sourceFs.write(dumpString("        this->DataTable = this->Loader->Object;\r\n"));
        sourceFs.write(dumpString(String.format("        this->DataTable->OnDataTableChanged().AddUObject(this, &U%s::OnReload);\r\n", helperClazzName)));
        sourceFs.write(dumpString("        OnReload();\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("    else\r\n"));
        sourceFs.write(dumpString("    {\r\n"));
        sourceFs.write(dumpString("        this->DataTable = nullptr;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // OnReload()
        sourceFs.write(dumpString(String.format("void U%s::OnReload()\r\n", helperClazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString("    // TODO Rebuild Index\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetRowName(...)
        sourceFs.write(dumpString(String.format("FName U%s::GetRowName(%s)\r\n", helperClazzName, getDataRowKeyToNameParamsSpecify(rule))));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    return %s;\r\n", getDataRowKeyToNameExpression(rule))));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetDataRowName(...)
        sourceFs.write(dumpString(String.format("FName U%s::GetDataRowName(%s) const\r\n", helperClazzName, getDataRowKeyToNameParamsSpecify(rule))));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    return U%s::GetRowName(%s);\r\n", helperClazzName, getDataRowKeyToNameParamsPass(rule, ""))));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetTableRowName(const T& TableRow)
        sourceFs.write(dumpString(String.format("FName U%s::GetTableRowName(const F%s& TableRow) const\r\n", helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    return GetDataRowName(%s);\r\n", getDataRowKeyToNameParamsPass(rule, "TableRow."))));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetTableRowName(const T& TableRow)
        sourceFs.write(dumpString(
                String.format("const F%s& U%s::GetDataRowByName(const FName& Name, bool& %s) const\r\n", codeInfo.clazzName, helperClazzName, varIsValidName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
        sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
        sourceFs.write(dumpString("        return this->Empty;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("    FString Context;\r\n"));
        sourceFs.write(
                dumpString(String.format("    F%s* LookupRow = DataTable->FindRow<F%s>(Name, Context, false);\r\n", codeInfo.clazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("    if (!LookupRow) {\r\n"));
        sourceFs.write(dumpString("        return this->Empty;\r\n"));
        sourceFs.write(dumpString("    };\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString(String.format("    %s = true;\r\n", varIsValidName)));
        sourceFs.write(dumpString("    return *LookupRow;\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetDataRowByKey(..., bool& IsValid)
        sourceFs.write(dumpString(String.format("const F%s& U%s::GetDataRowByKey(%s, bool& %s) const\r\n", codeInfo.clazzName, helperClazzName,
                getDataRowKeyToNameParamsSpecify(rule), varIsValidName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(
                dumpString(String.format("    return GetDataRowByName(GetDataRowName(%s), %s);\r\n", getDataRowKeyToNameParamsPass(rule, ""), varIsValidName)));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // ForeachRow(TFunctionRef<void (const FName& Key, const T& Value)> Predicate)
        sourceFs.write(dumpString(String.format("bool U%s::ForeachRow(TFunctionRef<void (const FName& Key, const F%s& Value)> Predicate) const\r\n",
                helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
        sourceFs.write(dumpString("        return false;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("    FString Context;\r\n"));
        sourceFs.write(dumpString("    this->DataTable->ForeachRow(Context, Predicate);\r\n"));
        sourceFs.write(dumpString("    return true;\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetRawDataTable(bool& IsValid)
        sourceFs.write(dumpString(String.format("UDataTable* U%s::GetRawDataTable(bool& %s) const\r\n", helperClazzName, varIsValidName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
        sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
        sourceFs.write(dumpString("        return NULL;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString(String.format("    %s = true;\r\n", varIsValidName)));
        sourceFs.write(dumpString("    return this->DataTable;\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // static void ClearDataRow(const F%s& TableRow);
        sourceFs.write(dumpString(String.format("void U%s::ClearRow(F%s& TableRow)\r\n", helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
            writeUETypeSetDefaultCode(sourceFs, "    TableRow", wrapper);
        }
        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.valueFields.get(i);
            writeUETypeSetDefaultCode(sourceFs, "    TableRow", wrapper);
        }
        sourceFs.write(dumpString("}\r\n\r\n"));

        // void ClearDataRow(const F%s& TableRow) const;
        sourceFs.write(dumpString(String.format("void U%s::ClearDataRow(F%s& TableRow) const\r\n", helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    U%s::ClearRow(TableRow);\r\n", helperClazzName)));
        sourceFs.write(dumpString("}\r\n\r\n"));
        sourceFs.close();
    }
}
