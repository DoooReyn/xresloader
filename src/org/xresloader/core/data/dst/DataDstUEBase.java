package org.xresloader.core.data.dst;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.regex.Pattern;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;
import org.xresloader.core.ProgramOptions;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstChildrenNode;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstFieldDescriptor;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstFieldExt;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstMessageDescriptor;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstMessageExt;
import org.xresloader.core.data.dst.DataDstWriterNode.JAVA_TYPE;
import org.xresloader.core.data.err.ConvException;
import org.xresloader.core.data.src.DataContainer;
import org.xresloader.core.data.src.DataSrcImpl;
import org.xresloader.core.engine.IdentifyEngine;
import org.xresloader.core.scheme.SchemeConf;

/**
 * Created by owentou on 2019/04/08.
 */
public abstract class DataDstUEBase extends DataDstImpl {
    static private Pattern fileToClassMatcher = Pattern.compile("[" + Pattern.quote(".-()_") + "\\s]");
    static private String codeHeaderPrefixGuard = String.join("\r\n",
            "// This file is generated by xresloader, please don't edit it.", "", "#pragma once", "");
    static private String codeHeaderPrefix1 = String.join("\r\n", "", "#include \"CoreMinimal.h\"",
            "#include \"UObject/ConstructorHelpers.h\"", "#include \"Engine/DataTable.h\"", "");
    static private String codeHeaderIncludeGenerated = "#include \"%s.generated.h\"";
    static private String codeHeaderPrefix2 = String.join("\r\n", "", "", "", "USTRUCT(BlueprintType)", "");
    static private String codeHeaderClassName = "struct %s : public FTableRowBase";
    static private String codeHeaderPrefix3 = String.join("\r\n", "", "{", "    GENERATED_USTRUCT_BODY()", "",
            "    // Start of fields");
    static private String codeHeaderSuffix = "\r\n};";
    static private String codeSourceInclude = "#include \"%s.h\"\r\n";
    static private String ueImportFile = "UnreaImportSettings.json";
    private Charset encodingCache = null;
    private String headerFieldUProperty = null;
    private String headerFieldUFunction = null;

    public enum NAME_TYPE {
        LONG, STRING, DOUBLE
    }

    public class UEDataRowRule {
        public String helper = null;
        public String description = null;
        public NAME_TYPE nameType = NAME_TYPE.LONG;
        public ArrayList<DataDstWriterNodeWrapper> keyFields = null;
        public ArrayList<DataDstWriterNodeWrapper> valueFields = null;
    }

    @Override
    public boolean init() {
        encodingCache = null;
        headerFieldUProperty = null;
        return true;
    }

    /**
     * @return 协议处理器名字
     */
    public String name() {
        return "ue";
    }

    static public class UECodeInfo {
        public String header = null;
        public String source = null;
        public String outputFile = null;
        public String outputDir = null;
        public String headerDir = null;
        public String sourceDir = null;
        public String includeDir = null;
        public String packageName = null;
        public String clazzName = null;
        public String baseName = null;
        public String category = null;
        public String destinationPath = null;

        public boolean hasGeneratedCode = false;
        public HashMap<String, UECodeInfo> dependencies = null;
        public DataDstWriterNode desc = null;

        UECodeInfo makeDependence(DataDstWriterNode desc) {
            // 这里必须和build_data一样
            String originClazzName = getUETypeName(desc);
            if (dependencies != null && dependencies.containsKey(originClazzName)) {
                return dependencies.get(originClazzName);
            }

            UECodeInfo ret = getCodeCache(originClazzName);
            if (ret != null) {
                if (null == dependencies) {
                    dependencies = new HashMap<String, UECodeInfo>();
                }
                dependencies.put(originClazzName, ret);

                ret.desc = desc;
                return ret;
            }

            ret = new UECodeInfo();
            ret.desc = desc;
            ret.outputFile = this.outputFile;
            ret.outputDir = this.outputDir;
            ret.headerDir = this.headerDir;
            ret.sourceDir = this.sourceDir;
            ret.includeDir = this.includeDir;
            ret.category = this.category;
            ret.destinationPath = this.destinationPath;
            ret.packageName = packageName;

            ret.initClazzName(originClazzName);

            if (null == dependencies) {
                dependencies = new HashMap<String, UECodeInfo>();
            }
            dependencies.put(originClazzName, ret);

            setCodeCache(originClazzName, ret);
            return ret;
        }

        void initClazzName(String originClazzName) {
            this.clazzName = originClazzName;
            if (!originClazzName.isEmpty() && originClazzName.charAt(0) == 'F') {
                this.baseName = originClazzName.substring(1);
            } else {
                this.baseName = originClazzName;
            }
            this.header = this.headerDir + File.separator + this.baseName + ".h";
            this.source = this.sourceDir + File.separator + this.baseName + ".cpp";
        }
    }

    static private HashMap<String, UECodeInfo> globalCodeCache = new HashMap<String, UECodeInfo>();
    static private HashSet<String> globalCodeWrittenCache = new HashSet<String>();

    static UECodeInfo getCodeCache(String clazzName) {
        if (clazzName == null || clazzName.isEmpty()) {
            clazzName = "";
        } else {
            clazzName = getIdentName(clazzName);
        }

        return globalCodeCache.getOrDefault(clazzName, null);
    }

    static void setCodeCache(String clazzName, UECodeInfo code) {
        if (clazzName == null || clazzName.isEmpty()) {
            clazzName = "";
        } else {
            clazzName = getIdentName(clazzName);
        }

        globalCodeCache.put(clazzName, code);
    }

    static public class DataDstWriterNodeWrapper implements Comparable<DataDstWriterNodeWrapper> {
        public String varName = null;
        public ArrayList<DataDstWriterNode> descs = new ArrayList<DataDstWriterNode>();
        public boolean isGenerated = false;
        public boolean isList = false;
        public ArrayList<DataDstWriterNodeWrapper> children = null;

        public DataDstWriterNode GetWriterNode(int i) {
            if (i >= descs.size()) {
                return null;
            }

            return descs.get(i);
        }

        public JAVA_TYPE getJavaType() {
            DataDstWriterNode n = GetWriterNode(0);
            if (n == null) {
                return JAVA_TYPE.STRING;
            }

            return n.getType();
        }

        static private DataDstMessageExt emptyMsgExt = new DataDstMessageExt();

        public DataDstMessageExt getMessageExtension() {
            DataDstWriterNode n = GetWriterNode(0);
            if (n == null) {
                return emptyMsgExt;
            }

            return n.getMessageExtension();
        }

        static private DataDstFieldExt emptyFieldExt = new DataDstFieldExt();

        public DataDstFieldExt getFieldExtension() {
            DataDstWriterNode n = GetWriterNode(0);
            if (n == null) {
                return emptyFieldExt;
            }

            return n.getFieldExtension();
        }

        @Override
        public int compareTo(DataDstWriterNodeWrapper r) {
            for (int i = 0; i < descs.size() && i < r.descs.size(); ++i) {
                DataDstWriterNode ld = GetWriterNode(i);
                DataDstWriterNode rd = r.GetWriterNode(i);
                int lv = 0;
                if (ld != null && ld.identify != null) {
                    lv = ld.identify.index;
                }
                int rv = 0;
                if (rd != null && rd.identify != null) {
                    rv = rd.identify.index;
                }

                if (lv != rv) {
                    return lv - rv;
                }
            }

            return descs.size() - r.descs.size();
        }
    }

    static public String getIdentName(String in) {
        String[] segs = fileToClassMatcher.split(in);
        if (SchemeConf.getInstance().getUECSVOptions().enableCaseConvert) {
            for (int i = 0; i < segs.length; ++i) {
                if (!segs[i].isEmpty() && Character.isLowerCase(segs[i].charAt(0))) {
                    segs[i] = Character.toUpperCase(segs[i].charAt(0)) + segs[i].substring(1);
                }
            }
            return String.join("", segs);
        } else {
            return String.join("_", segs);
        }
    }

    public UECodeInfo getCodeInfo(String outputFile, String originClazzName, DataDstWriterNode desc)
            throws IOException {
        File ofd = new File(outputFile);
        if (originClazzName == null || originClazzName.isEmpty()) {
            if (null == desc) {
                String fileName = ofd.getName();
                int lastDot = fileName.lastIndexOf('.');
                if (lastDot < 0) {
                    originClazzName = fileName;
                } else {
                    originClazzName = fileName.substring(0, lastDot);
                }
                originClazzName = "F" + getIdentName(originClazzName);
            } else {
                originClazzName = getUETypeName(desc);
            }
        }

        UECodeInfo ret = getCodeCache(originClazzName);
        if (ret != null) {
            ret.desc = desc;
            return ret;
        }

        ret = new UECodeInfo();
        ret.desc = desc;
        ret.outputFile = ofd.getCanonicalFile().getAbsolutePath();
        ret.outputDir = ofd.getParentFile().getCanonicalFile().getAbsolutePath();
        // redirect header directory and source directory
        String codeOutputDir = SchemeConf.getInstance().getUECSVOptions().codeOutputDir;
        if (codeOutputDir.isEmpty()) {
            codeOutputDir = (new File(ProgramOptions.getInstance().outputDirectory)).getCanonicalFile()
                    .getAbsolutePath();
        }
        if (SchemeConf.getInstance().getUECSVOptions().category.isEmpty()) {
            ret.category = "DataTable";
        } else {
            ret.category = SchemeConf.getInstance().getUECSVOptions().category;
        }
        if (!SchemeConf.getInstance().getUECSVOptions().codeOutputPublicDir.isEmpty()) {
            String pubDir = SchemeConf.getInstance().getUECSVOptions().codeOutputPublicDir;
            ret.headerDir = codeOutputDir + File.separator + pubDir;
            if (pubDir.charAt(0) == '/' || pubDir.charAt(0) == '\\') {
                pubDir = pubDir.substring(1);
            }
            if (pubDir.substring(0, 7).equalsIgnoreCase("Public/")) {
                ret.includeDir = pubDir.substring(7).replace('\\', '/');
            } else {
                ret.includeDir = pubDir.replace('\\', '/');
            }
            if (!ret.includeDir.isEmpty() && !ret.includeDir.endsWith("/")) {
                ret.includeDir = ret.includeDir + "/";
            }
        } else {
            ret.headerDir = codeOutputDir;
            ret.includeDir = "";
        }
        if (!SchemeConf.getInstance().getUECSVOptions().codeOutputPrivateDir.isEmpty()) {
            ret.sourceDir = codeOutputDir + File.separator
                    + SchemeConf.getInstance().getUECSVOptions().codeOutputPrivateDir;
        } else {
            ret.sourceDir = codeOutputDir;
        }

        ret.initClazzName(originClazzName);
        ret.destinationPath = "DataTable";
        if (ret.includeDir.length() > 1) {
            ret.destinationPath = String.format("%s", ret.includeDir.substring(0, ret.includeDir.length() - 1));
        }

        setCodeCache(originClazzName, ret);
        return ret;
    }

    public void writeImportSettings(UECodeInfo code) {
        File importFile = new File(code.outputDir + File.separator + ueImportFile);
        if (!importFile.getParentFile().exists()) {
            importFile.getParentFile().mkdirs();
        }

        JSONObject importObj;
        JSONArray groupObj;

        if (importFile.exists()) {
            try {
                importObj = new JSONObject(new JSONTokener(new FileInputStream(importFile)));
            } catch (JSONException | FileNotFoundException e) {
                importObj = new JSONObject();
                ProgramOptions.getLoger().error("Read json from %s failed, %s", importFile.getAbsolutePath(),
                        e.getMessage());
            }
        } else {
            importObj = new JSONObject();
        }

        try {
            if (importObj.has("ImportGroups")) {
                groupObj = importObj.getJSONArray("ImportGroups");
            } else {
                groupObj = new JSONArray();
                importObj.put("ImportGroups", groupObj);
            }

            JSONObject selectedItem = null;
            for (int i = 0; i < groupObj.length(); ++i) {
                JSONObject item = groupObj.getJSONObject(i);
                if (item.has("ImportSettings")) {
                    if (item.getJSONObject("ImportSettings").optString("ImportRowStruct").equals(code.clazzName)) {
                        selectedItem = item;
                        break;
                    }
                }
            }

            if (null == selectedItem) {
                selectedItem = new JSONObject();
                groupObj.put(selectedItem);
            }

            selectedItem.put("GroupName", code.category);

            JSONArray dataFileList = new JSONArray();
            dataFileList.put(code.outputFile);
            selectedItem.put("Filenames", dataFileList);
            selectedItem.put("DestinationPath", code.destinationPath);
            selectedItem.put("bReplaceExisting", "true");
            selectedItem.put("bSkipReadOnly", "true");
            selectedItem.put("FactoryName", "ReimportDataTableFactory");

            JSONObject importSetting = null;
            if (selectedItem.has("ImportSettings")) {
                importSetting = selectedItem.getJSONObject("ImportSettings");
            } else {
                importSetting = new JSONObject();
                selectedItem.put("ImportSettings", importSetting);
            }

            importSetting.put("ImportRowStruct", code.baseName); // 这个得是不带F前缀的名字
            importSetting.put("ImportType", "ECSV_DataTable");

            FileOutputStream fos = new FileOutputStream(importFile, false);
            fos.write(dumpString(importObj.toString(4)));
            fos.close();
        } catch (Exception e) {
            ProgramOptions.getLoger().error("Write json to %s failed, %s", importFile.getAbsolutePath(),
                    e.getMessage());
        }
    }

    private byte[] dumpString(String in) {
        if (null != encodingCache) {
            return in.getBytes(encodingCache);
        }

        // 带编码的输出
        String encoding = SchemeConf.getInstance().getKey().getEncoding();
        if (null == encoding || encoding.isEmpty())
            return in.toString().getBytes();

        encodingCache = Charset.forName(encoding);
        return in.getBytes(encodingCache);
    }

    public FileOutputStream createCodeHeaderFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.header);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.header, false);
        fos.write(dumpString(codeHeaderPrefixGuard));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
        }
        fos.write(dumpString(codeHeaderPrefix1));

        // include all dependicies
        if (code.dependencies != null) {
            for (HashMap.Entry<String, UECodeInfo> varPair : code.dependencies.entrySet()) {
                UECodeInfo depCodeInfo = varPair.getValue();
                fos.write(dumpString(String.format(codeSourceInclude, depCodeInfo.includeDir + depCodeInfo.baseName)));
            }
        }

        fos.write(dumpString(String.format(codeHeaderIncludeGenerated, code.baseName)));
        fos.write(dumpString(codeHeaderPrefix2));
        fos.write(dumpString(String.format(codeHeaderClassName, code.clazzName)));
        fos.write(dumpString(codeHeaderPrefix3));

        return fos;
    }

    public FileOutputStream createCodeSourceFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.source);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.source, false);
        fos.write(dumpString("// This file is generated by xresloader, please don't edit it.\r\n\r\n"));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
            fos.write(dumpString("\r\n"));
        }

        fos.write(dumpString(String.format(codeSourceInclude, code.includeDir + code.baseName)));

        return fos;
    }

    @Override
    public final byte[] build(DataDstImpl compiler) throws ConvException {
        // DataDstJava.DataDstObject data_obj = build_data(compiler);
        Object buildObj = null;
        globalCodeCache.clear();

        try {
            buildObj = buildForUEOnInit();

            build_data(buildObj, compiler);
        } catch (IOException e) {
            throw new ConvException(String.format("build data for %s failed. msg: %s", name(), e.getMessage()));
        }

        return buildForUEOnFinal(buildObj);
    }

    abstract protected boolean isRecursiveEnabled();

    abstract protected Object buildForUEOnInit() throws IOException;

    abstract protected byte[] buildForUEOnFinal(Object buildObj);

    abstract protected void buildForUEOnPrintHeader(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule)
            throws IOException;

    abstract protected void buildForUEOnPrintRecord(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException;

    private UEDataRowRule rebuildCodeRule(UECodeInfo codeInfo) throws ConvException {
        if (null == codeInfo.desc) {
            return null;
        }

        // 生成描述集,CSV必须固定化描述集，可能需要把字段平铺开来。
        ArrayList<DataDstWriterNodeWrapper> expandedDesc = expandDescription(null, codeInfo.desc, "", 0);

        if (expandedDesc == null || expandedDesc.isEmpty()) {
            return null;
        }

        // 如果是递归模式,第一层是Message
        if (isRecursiveEnabled()) {
            expandedDesc = expandedDesc.get(0).children;
        }
        if (expandedDesc == null || expandedDesc.isEmpty()) {
            return null;
        }

        // ======================================================================================================
        UEDataRowRule rule = splitDataRowDesc(codeInfo, expandedDesc);
        rule.helper = codeInfo.desc.getMessageExtension().mutableUE().helper;
        rule.description = codeInfo.desc.getMessageExtension().description;
        // ======================================================================================================

        return rule;

    }

    protected final void build_data(Object buildObj, DataDstImpl compiler) throws ConvException, IOException {
        while (DataSrcImpl.getOurInstance().next_table()) {
            // 生成描述集
            DataDstWriterNode desc = compiler.compile();

            // 这里规则必须和makeDependence(desc)一样
            String originClazzName = getUETypeName(desc);
            UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), originClazzName, desc);
            UEDataRowRule rule = rebuildCodeRule(codeInfo);

            if (rule == null) {
                continue;
            }

            if (rule.keyFields.isEmpty()) {
                throw new ConvException("DataTable for UE must has a Name field or has field(s) with key_tag");
            }

            // 输出header
            ArrayList<Object> row_data = new ArrayList<Object>();
            row_data.ensureCapacity(rule.keyFields.size() + rule.valueFields.size());
            for (int i = 0; i < rule.keyFields.size(); ++i) {
                row_data.add(rule.keyFields.get(i).varName);
            }
            for (int i = 0; i < rule.valueFields.size(); ++i) {
                row_data.add(rule.valueFields.get(i).varName);
            }
            buildForUEOnPrintHeader(buildObj, row_data, rule);

            // 输出数据
            while (DataSrcImpl.getOurInstance().next_row()) {
                row_data = new ArrayList<Object>();
                row_data.ensureCapacity(rule.keyFields.size() + rule.valueFields.size());

                // 先用特殊规则导入Name字段,Name字段可能是合成字段
                if (!rule.keyFields.isEmpty()) {
                    row_data.add(pickNameField(rule));
                    for (int i = 1; i < rule.keyFields.size(); ++i) {
                        row_data.add(pickValueField(rule.keyFields.get(i)));
                    }
                }
                for (int i = 0; i < rule.valueFields.size(); ++i) {
                    row_data.add(pickValueField(rule.valueFields.get(i)));
                }
                buildForUEOnPrintRecord(buildObj, row_data, rule, codeInfo);
            }

            // 加载代码
            writeCodeFiles(rule, codeInfo);

            // 写出导出文件
            writeImportSettings(codeInfo);
        }
    }

    private void writeCodeFiles(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException, ConvException {
        if (null == codeInfo || codeInfo.hasGeneratedCode || null == rule) {
            return;
        }
        codeInfo.hasGeneratedCode = true;
        if (codeInfo.dependencies != null) {
            codeInfo.dependencies.clear();
        }

        // 递归写出依赖的数据结构
        if (isRecursiveEnabled() && null != codeInfo.desc && codeInfo.desc.getChildren() != null) {
            for (HashMap.Entry<String, DataDstChildrenNode> child : codeInfo.desc.getChildren().entrySet()) {
                if (child.getValue().nodes.isEmpty()) {
                    continue;
                }

                if (child.getValue().nodes.get(0).getType() == JAVA_TYPE.MESSAGE) {
                    UECodeInfo depCodeInfo = codeInfo.makeDependence(child.getValue().nodes.get(0));
                    if (null == depCodeInfo || depCodeInfo.hasGeneratedCode) {
                        continue;
                    }

                    UEDataRowRule depRule = rebuildCodeRule(depCodeInfo);
                    writeCodeFiles(depRule, depCodeInfo);
                }
            }
        }

        // 加载代码
        writeCodeHeaderFile(rule, codeInfo);
        writeCodeSourceFile(rule, codeInfo);
    }

    private Object pickNameField(UEDataRowRule rule) throws ConvException {
        if (rule.keyFields.isEmpty()) {
            return null;
        }

        // 如果是直接采用原始字段则直接返回原始字段数据
        if (null != rule.keyFields.get(0).descs && !rule.keyFields.get(0).descs.isEmpty()) {
            return pickValueField(rule.keyFields.get(0));
        }

        switch (rule.nameType) {
        case LONG: {
            long ret = 0;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
                Object val = pickValueField(wrapper);
                if (val instanceof Number) {
                    ret = ret + wrapper.getFieldExtension().mutableUE().keyTag * ((Number) val).longValue();
                } else {
                    ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                            * Long.valueOf(pickValueField(rule.keyFields.get(i)).toString());
                }
            }

            return ret;
        }
        case DOUBLE: {
            double ret = 0.0;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
                Object val = pickValueField(wrapper);
                if (val instanceof Number) {
                    ret = ret + wrapper.getFieldExtension().mutableUE().keyTag * ((Number) val).doubleValue();
                } else {
                    ret = ret + wrapper.getFieldExtension().mutableUE().keyTag
                            * Double.valueOf(pickValueField(rule.keyFields.get(i)).toString());
                }
            }

            return ret;
        }
        case STRING: {
            ArrayList<String> ls = new ArrayList<String>();
            ls.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                ls.add(pickValueField(rule.keyFields.get(i)).toString());
            }

            return String.join("", ls);
        }
        default:
            return 0;
        }
    }

    protected Object pickValueField(DataDstWriterNodeWrapper descWrapper) throws ConvException {
        return pickValueFieldBaseImpl(descWrapper, 0);
    }

    protected Object pickValueFieldBaseImpl(DataDstWriterNodeWrapper descWrapper, int pickIndex) throws ConvException {
        if (descWrapper.isList || pickIndex >= descWrapper.descs.size()) {
            return null;
        }

        DataDstWriterNode desc = descWrapper.GetWriterNode(pickIndex);
        return pickValueFieldBaseImpl(desc);
    }

    protected Object pickValueFieldBaseImpl(DataDstWriterNode desc) throws ConvException {
        if (null == desc || null == desc.identify || desc.getType() == DataDstWriterNode.JAVA_TYPE.MESSAGE) {
            return null;
        }

        switch (desc.getType()) {
        case INT: {
            DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
            if (null != ret && ret.valid) {
                return ret.value.intValue();
            }
            break;
        }

        case LONG: {
            DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
            if (null != ret && ret.valid) {
                return ret.value.longValue();
            }
            break;
        }

        case FLOAT: {
            DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
            if (null != ret && ret.valid) {
                return ret.value.floatValue();
            }
            break;
        }

        case DOUBLE: {
            DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
            if (null != ret && ret.valid) {
                return ret.value.doubleValue();
            }
            break;
        }

        case BOOLEAN: {
            DataContainer<Boolean> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, false);
            if (null != ret && ret.valid) {
                return ret.value.booleanValue();
            }
            break;
        }

        case STRING: {
            DataContainer<String> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
            if (null != ret && ret.valid) {
                return ret.value;
            }
            break;
        }

        case BYTES: {
            DataContainer<String> res = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
            if (null != res && res.valid) {
                String encoding = SchemeConf.getInstance().getKey().getEncoding();
                if (null == encoding || encoding.isEmpty()) {
                    return Base64.getEncoder().encodeToString(res.value.getBytes());
                } else {
                    return Base64.getEncoder().encodeToString(res.value.getBytes(Charset.forName(encoding)));
                }
            }
            break;
        }

        case MESSAGE: {
            break;
        }
        default:
            break;
        }

        return null;
    }

    protected ArrayList<DataDstWriterNodeWrapper> expandDescription(ArrayList<DataDstWriterNodeWrapper> descs,
            DataDstWriterNode desc, String prefix, int listCapacity) {
        boolean isLeaf = true;
        ArrayList<DataDstWriterNodeWrapper> children = null;
        switch (desc.getType()) {
        case INT: {
            break;
        }
        case LONG: {
            break;
        }
        case BOOLEAN: {
            break;
        }
        case STRING: {
            break;
        }
        case BYTES: {
            break;
        }
        case FLOAT: {
            break;
        }
        case DOUBLE: {
            break;
        }
        case MESSAGE: {
            // if it's top message or is not recursive mode
            if (!isRecursiveEnabled()) {
                isLeaf = false;
            }

            if (descs == null) {
                descs = new ArrayList<DataDstWriterNodeWrapper>();
                if (isLeaf) {
                    // 留一个给Name字段
                    descs.ensureCapacity(desc.getChildren().size() + 2);
                } else {
                    descs.ensureCapacity(Math.max(desc.getChildren().size() * 2, 32));
                }
            }

            for (HashMap.Entry<String, DataDstChildrenNode> child : desc.getChildren().entrySet()) {
                String varName = getIdentName(child.getKey());
                if (isLeaf) {
                    if (child.getValue().innerDesc.isList()) {
                        if (child.getValue().nodes.size() <= 0) {
                            children = new ArrayList<DataDstWriterNodeWrapper>();
                            continue;
                        }

                        DataDstWriterNode child_desc = child.getValue().nodes.get(0);
                        children = expandDescription(children, child_desc, "_" + varName,
                                child.getValue().nodes.size());

                        if (!children.isEmpty()) {
                            continue;
                        }

                        DataDstWriterNodeWrapper lastChild = children.get(children.size() - 1);
                        if (lastChild.descs.isEmpty() || lastChild.GetWriterNode(0) != child_desc) {
                            ProgramOptions.getLoger().error("Add child %s for %s failed.", child.getKey(),
                                    desc.getFullName());
                            continue;
                        }

                        // 把剩下的也加进去
                        for (int i = 1; i < child.getValue().nodes.size(); ++i) {
                            lastChild.descs.add(child.getValue().nodes.get(i));
                        }
                    } else if (!child.getValue().nodes.isEmpty()) {
                        children = expandDescription(children, child.getValue().nodes.get(0), "_" + varName, 0);
                    }
                } else {
                    if (child.getValue().innerDesc.isList()) {
                        for (int i = 0; i < child.getValue().nodes.size(); ++i) {
                            DataDstWriterNode child_desc = child.getValue().nodes.get(i);
                            expandDescription(descs, child_desc, prefix + String.format("_%s_%d", varName, i), 0);
                        }
                    } else if (!child.getValue().nodes.isEmpty()) {
                        expandDescription(descs, child.getValue().nodes.get(0), prefix + "_" + varName, 0);
                    }
                }
            }

            break;
        }
        }

        if (!isLeaf) {
            return descs;
        }

        if (descs == null) {
            descs = new ArrayList<DataDstWriterNodeWrapper>();
            if (listCapacity > 0) {
                descs.ensureCapacity(listCapacity);
            } else {
                descs.ensureCapacity(2);
            }
        }

        DataDstWriterNodeWrapper res = new DataDstWriterNodeWrapper();
        if (prefix == null || prefix.isEmpty()) {
            res.varName = "";
        } else if (prefix.charAt(0) == '_') {
            res.varName = prefix.substring(1);
        } else {
            res.varName = prefix;
        }
        res.descs.add(desc);
        res.children = children;
        res.isList = listCapacity > 0;
        descs.add(res);

        return descs;
    }

    /**
     * 和输出格式无关的常量转储功能
     *
     * @param data 常量数据集
     * @return 常量代码
     */
    abstract public String dumpConstForUE(HashMap<String, Object> data, UEDataRowRule rule) throws IOException;

    /**
     * 转储常量数据
     *
     * @return 常量数据,不支持的时候返回空
     * @throws IOException
     */
    public final byte[] dumpConst(HashMap<String, Object> data) throws ConvException, IOException {
        globalCodeCache.clear();

        // 加载代码
        UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), null, null);
        DataDstWriterNode ddNode = null;

        // const完整路径都在data里了，不需要额外的包名(可能包含多个包)
        // ======================================================================================================
        ArrayList<DataDstWriterNodeWrapper> expandedDesc = new ArrayList<DataDstWriterNodeWrapper>();
        DataDstWriterNodeWrapper constNameNode = new DataDstWriterNodeWrapper();
        ddNode = DataDstWriterNode.create(null,
                DataDstWriterNode.getDefaultMessageDescriptor(DataDstWriterNode.JAVA_TYPE.STRING));
        ddNode.setFieldDescriptor(new DataDstFieldDescriptor(ddNode.getTypeDescriptor(), 1, "Name", false));
        ddNode.identify = IdentifyEngine.n2i("Name", 0);
        constNameNode.descs.add(ddNode);
        constNameNode.varName = getIdentName("Name");
        constNameNode.isGenerated = true;
        constNameNode.isList = false;
        expandedDesc.add(constNameNode);

        DataDstWriterNodeWrapper constValueNode = new DataDstWriterNodeWrapper();
        ddNode = DataDstWriterNode.create(null,
                DataDstWriterNode.getDefaultMessageDescriptor(DataDstWriterNode.JAVA_TYPE.INT));
        ddNode.setFieldDescriptor(new DataDstFieldDescriptor(ddNode.getTypeDescriptor(), 1, "Value", false));
        ddNode.identify = IdentifyEngine.n2i("Value", 1);
        constValueNode.descs.add(ddNode);
        constValueNode.varName = getIdentName("Value");
        constValueNode.isGenerated = true;
        constValueNode.isList = false;
        expandedDesc.add(constValueNode);

        UEDataRowRule constRule = splitDataRowDesc(codeInfo, expandedDesc);
        constRule.helper = "helper";
        constRule.nameType = NAME_TYPE.STRING;
        // ======================================================================================================

        String constCode = dumpConstForUE(data, constRule);

        // 加载代码
        writeCodeFiles(constRule, codeInfo);

        // 写出导出文件
        writeImportSettings(codeInfo);

        // 带编码的输出
        return dumpString(constCode);
    }

    private final String getHeaderFieldUProperty() {
        if (null == headerFieldUProperty) {
            LinkedList<String> ls = new LinkedList<String>();
            if (!SchemeConf.getInstance().getUECSVOptions().editAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUECSVOptions().editAccess);
            }

            if (!SchemeConf.getInstance().getUECSVOptions().category.isEmpty()
                    && !SchemeConf.getInstance().getUECSVOptions().blueprintAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUECSVOptions().blueprintAccess);
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUECSVOptions().category));
            }
            headerFieldUProperty = String.format("    UPROPERTY(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUProperty;
    }

    private final String getHeaderFieldUFunction() {
        if (null == headerFieldUFunction) {
            LinkedList<String> ls = new LinkedList<String>();

            ls.add("BlueprintCallable");
            if (!SchemeConf.getInstance().getUECSVOptions().category.isEmpty()) {
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUECSVOptions().category));
            }
            headerFieldUFunction = String.format("    UFUNCTION(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUFunction;
    }

    private final String getDataRowKeyToNameParamsSpecify(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.descs != null && !nameNode.descs.isEmpty()) {
            String ueTypeName = getUETypeName(nameNode.GetWriterNode(0));
            if (ueTypeName.equalsIgnoreCase("FString")) {
                ueTypeName = "FName";
            }
            return String.format("%s %s", ueTypeName, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s %s", getUETypeName(keyNode.GetWriterNode(0)), keyNode.varName));
        }

        return String.join(", ", params);
    }

    private final String getDataRowKeyToNameParamsPass(UEDataRowRule rule, String prefix) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        if (null == prefix) {
            prefix = "";
        }
        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.descs != null && !nameNode.descs.isEmpty()) {
            return String.format("%s%s", prefix, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s%s", prefix, keyNode.varName));
        }

        return String.join(", ", params);
    }

    /**
     * @see pickNameField
     * @param rule
     * @return
     */
    private final String getDataRowKeyToNameExpression(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (!nameNode.descs.isEmpty()) {
            String ueTypeNameIdent = null;
            if (null != nameNode.getFieldExtension()) {
                ueTypeNameIdent = nameNode.getFieldExtension().mutableUE().ueTypeName;
            }
            if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                return String.format("*%s.ToString()", nameNode.varName);
            }

            switch (rule.nameType) {
            case LONG:
                return String.format("*FString::Printf(TEXT(\"%%lld\"), static_cast<long long>(%s))", nameNode.varName);
            case DOUBLE:
                return String.format("*FString::Printf(TEXT(\"%%g\"), static_cast<double>(%s))", nameNode.varName);
            case STRING:
                return nameNode.varName;
            default:
                return "/** Error Key Set **/";
            }
        }

        switch (rule.nameType) {
        case LONG: {
            ArrayList<String> params = new ArrayList<String>();
            params.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                params.add(String.format("static_cast<long long>(%s) * %s", keyNode.varName,
                        keyNode.getFieldExtension().mutableUE().keyTag));
            }
            return String.format("*FString::Printf(TEXT(\"%%lld\"), %s)", String.join(" + ", params));
        }
        case DOUBLE: {
            ArrayList<String> params = new ArrayList<String>();
            params.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                params.add(String.format("static_cast<double>(%s) * %s", keyNode.varName,
                        keyNode.getFieldExtension().mutableUE().keyTag));
            }
            return String.format("*FString::Printf(TEXT(\"%%g\"), %s)", String.join(" + ", params));
        }
        case STRING: {
            ArrayList<String> paramTypes = new ArrayList<String>();
            ArrayList<String> paramValues = new ArrayList<String>();
            paramTypes.ensureCapacity(rule.keyFields.size());
            paramValues.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                String fmt = getUETypeFormat(keyNode.getJavaType());
                paramTypes.add(fmt);

                String ueTypeNameIdent = keyNode.getFieldExtension().mutableUE().ueTypeName;
                if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                    paramValues.add(String.format("*%s.ToString()", keyNode.varName));
                } else if (fmt.equals("%s")) {
                    paramValues.add("*" + keyNode.varName);
                } else {
                    paramValues.add(keyNode.varName);
                }
            }

            return String.format("*FString::Printf(TEXT(\"%s\"), %s)", String.join("", paramTypes),
                    String.join(", ", paramValues));
        }
        default:
            return "/** Error Key Set **/";
        }
    }

    private final void writeCodeHeaderField(FileOutputStream fout, DataDstMessageDescriptor typeDesc,
            DataDstFieldDescriptor fieldDesc, String varName, boolean isList, boolean isGenerated) throws IOException {
        if ((varName == null || varName.isEmpty()) && fieldDesc != null) {
            varName = getIdentName(fieldDesc.getName());
        }

        fout.write(dumpString("\r\n"));
        DataDstWriterNode.JAVA_TYPE descType = DataDstWriterNode.JAVA_TYPE.STRING;
        if (null != typeDesc) {
            descType = typeDesc.getType();
            if (null != fieldDesc && fieldDesc.mutableExtension().description != null) {
                for (String descLine : fieldDesc.mutableExtension().description.replace("\r\n", "\n")
                        .replace("\r", "\n").split("\n")) {
                    fout.write(dumpString(String.format("    // %s\r\n", descLine)));
                }
            }
        }

        if (isGenerated) {
            fout.write(dumpString(String.format(
                    "    /** Field Type: %s, Name: %s. This field is generated for UE Editor compatible. **/\r\n",
                    descType.name(), varName)));
        } else {
            fout.write(dumpString(String.format("    /** Field Type: %s, Name: %s **/\r\n", descType.name(), varName)));
        }

        String ueTypeName = null;
        boolean enable = true;
        switch (descType) {
        case INT:
        case LONG:
        case FLOAT:
        case DOUBLE:
        case BOOLEAN:
            break;
        case STRING: {
            if (varName.equalsIgnoreCase("Name")) {
                ueTypeName = "FName";
            }
            break;
        }
        case BYTES: {
            if (varName.equalsIgnoreCase("Name")) {
                ueTypeName = "FName";
            }
            fout.write(
                    dumpString(String.format("    /** Bytes data will be encoded by base64 for %s */\r\n", varName)));
            break;
        }

        case MESSAGE: {
            ueTypeName = getUETypeName(typeDesc);
            break;
        }

        default:
            enable = false;
            fout.write(dumpString(String.format("    /** invalid data type %s of UE DataTable for %s */\r\n",
                    descType.name(), varName)));
            ProgramOptions.getLoger().error("invalid data type %s of UE DataTable for %s, should not called here.",
                    descType.name(), varName);
            break;
        }

        if (enable) {
            if (null == ueTypeName) {
                String ueTypeNameIdent = null;
                if (null != fieldDesc) {
                    ueTypeNameIdent = fieldDesc.mutableExtension().mutableUE().ueTypeName;
                }
                if (ueTypeNameIdent == null || ueTypeNameIdent.isEmpty()) {
                    ueTypeName = getUETypeName(typeDesc);
                } else {
                    if (null != fieldDesc && fieldDesc.mutableExtension().mutableUE().ueTypeIsClass) {
                        ueTypeName = String.format("TSoftClassPtr< %s >", ueTypeNameIdent);
                    } else {
                        ueTypeName = String.format("TSoftObjectPtr< %s >", ueTypeNameIdent);
                    }
                }
            }
            fout.write(dumpString(getHeaderFieldUProperty()));

            if (isList) {
                fout.write(dumpString(String.format("    TArray< %s > %s;\r\n", ueTypeName, varName)));
            } else {
                fout.write(dumpString(String.format("    %s %s;\r\n", ueTypeName, varName)));
            }
        }
    }

    static private final String getUETypeName(DataDstWriterNode desc) {
        if (null == desc) {
            return "FString";
        }

        return getUETypeName(desc.getTypeDescriptor());
    }

    static private final String getUETypeName(DataDstMessageDescriptor desc) {
        if (null == desc) {
            return "FString";
        }

        DataDstWriterNode.JAVA_TYPE type = desc.getType();
        switch (type) {
        case INT:
            return "int32";
        case LONG:
            return "int64";
        case FLOAT:
            return "float";
        case DOUBLE:
            return "double";
        case BOOLEAN:
            return "bool";
        case STRING:
            return "FString";
        case BYTES:
            return "FString";
        case MESSAGE:
            if (desc.getPackageName() == null || desc.getPackageName().isEmpty()) {
                return String.format("F%s", getIdentName(desc.getMessageName()));
            } else {
                return String.format("F%s", getIdentName(desc.getPackageName() + "_" + desc.getMessageName()));
            }
        default:
            return "";
        }
    }

    private final String getUETypeDefault(DataDstFieldDescriptor field) {
        DataDstWriterNode.JAVA_TYPE descType = field.getType();
        String ueTypeNameIdent = field.mutableExtension().mutableUE().ueTypeName;

        if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
            return "nullptr";
        }

        switch (descType) {
        case INT:
            return "0";
        case LONG:
            return "0";
        case FLOAT:
            return "0";
        case DOUBLE:
            return "0";
        case BOOLEAN:
            return "false";
        case STRING:
            return "TEXT(\"\")";
        case BYTES:
            return "TEXT(\"\")";
        case MESSAGE:
            return "nullptr";
        default:
            return "NULL";
        }
    }

    private final void writeUETypeSetDefaultCode(FileOutputStream sourceFs, String prefix, String varName,
            DataDstFieldDescriptor field, boolean isList) throws IOException {
        // if (wrapper.desc != null && wrapper.desc)
        if (isList) {
            sourceFs.write(dumpString(String.format("%s.%s.Reset(0);\r\n", prefix, varName)));
            return;
        }

        if (field.getType() == JAVA_TYPE.MESSAGE) {
            // 如果开启了嵌套模式，还要补全未使用的字段，因为可能被别处用到
            if (null != field.getTypeDescriptor().fields) {
                for (HashMap.Entry<String, DataDstFieldDescriptor> varPair : field.getTypeDescriptor().fields
                        .entrySet()) {
                    boolean isFieldList = varPair.getValue().isList();
                    if (!isRecursiveEnabled()) {
                        isFieldList = false;
                    }
                    writeUETypeSetDefaultCode(sourceFs, String.format("%s.%s", prefix, varName),
                            getIdentName(varPair.getKey()), varPair.getValue(), isFieldList);
                }
            }
            return;
        }

        sourceFs.write(dumpString(String.format("%s.%s = %s;\r\n", prefix, varName, getUETypeDefault(field))));
    }

    private final String getUETypeFormat(DataDstWriterNode.JAVA_TYPE type) {
        switch (type) {
        case INT:
            return "%d";
        case LONG:
            return "%lld";
        case FLOAT:
            return "%f";
        case DOUBLE:
            return "%llf";
        case BOOLEAN:
            return "%d";
        case STRING:
            return "%s";
        case BYTES:
            return "%s";
        case MESSAGE:
            return "nullptr";
        default:
            return "NULL";
        }
    }

    private final NAME_TYPE getUENameType(DataDstWriterNodeWrapper descWrapper) {
        DataDstWriterNode desc = descWrapper.GetWriterNode(0);
        if (desc == null) {
            return NAME_TYPE.STRING;
        }

        if (null != desc.identify && null != desc.getFieldExtension()) {
            String ueTypeName = desc.getFieldExtension().mutableUE().ueTypeName;
            if (ueTypeName != null && !ueTypeName.isEmpty()) {
                return NAME_TYPE.STRING;
            }
        }

        switch (desc.getType()) {
        case INT:
            return NAME_TYPE.LONG;
        case LONG:
            return NAME_TYPE.LONG;
        case FLOAT:
            return NAME_TYPE.DOUBLE;
        case DOUBLE:
            return NAME_TYPE.DOUBLE;
        case BOOLEAN:
            return NAME_TYPE.LONG;
        case STRING:
            return NAME_TYPE.STRING;
        case BYTES:
            return NAME_TYPE.STRING;
        case MESSAGE:
            return NAME_TYPE.STRING;
        default:
            return NAME_TYPE.LONG;
        }
    }

    private final UEDataRowRule splitDataRowDesc(UECodeInfo codeInfo, ArrayList<DataDstWriterNodeWrapper> expandedDesc)
            throws ConvException {
        UEDataRowRule ret = new UEDataRowRule();
        if (expandedDesc.isEmpty()) {
            return ret;
        }

        expandedDesc.sort(null);

        // UE 要求Key字段名必须是 Name，所以要查找Name的字段，没有的话要生成一个
        int nameIndex = -1;
        for (int i = 0; i < expandedDesc.size(); ++i) {
            DataDstWriterNodeWrapper nw = expandedDesc.get(i);
            if (nw.varName.equalsIgnoreCase("Name")) {
                if (nw.isList) {
                    throw new ConvException("Name field can not be array/list/repeated");
                }
                nameIndex = i;
                break;
            }
        }

        // 如果字段里本来就有，就直接用原始的字段
        if (nameIndex >= 0) {
            ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
            ret.keyFields.add(expandedDesc.get(nameIndex));
            expandedDesc.remove(nameIndex);
            ret.valueFields = expandedDesc;
            ret.nameType = getUENameType(ret.keyFields.get(0));
            return ret;
        }

        // 检查 key_tag，如果找到了，就优先用 key_tag
        DataDstWriterNodeWrapper namedKey = new DataDstWriterNodeWrapper();
        namedKey.varName = "Name";
        namedKey.isGenerated = true;

        ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.keyFields.ensureCapacity(expandedDesc.size());
        ret.keyFields.add(namedKey);

        ret.valueFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.valueFields.ensureCapacity(expandedDesc.size());

        ret.nameType = NAME_TYPE.LONG;
        for (int i = 0; i < expandedDesc.size(); ++i) {
            DataDstWriterNodeWrapper moved = expandedDesc.get(i);
            if (null != moved.descs && !moved.descs.isEmpty() && null != moved.GetWriterNode(0).identify
                    && moved.GetWriterNode(0).getFieldExtension().mutableUE().keyTag > 0) {
                if (moved.isList) {
                    throw new ConvException("Field with key_tag can not be array/list/repeated");
                }
                ret.keyFields.add(moved);
                switch (getUENameType(moved)) {
                case LONG:
                    ret.nameType = NAME_TYPE.LONG;
                    break;
                case DOUBLE:
                    if (ret.nameType == NAME_TYPE.LONG) {
                        ret.nameType = NAME_TYPE.DOUBLE;
                    }
                    break;
                case STRING:
                    ret.nameType = NAME_TYPE.STRING;
                    break;
                default:
                    break;
                }
            } else {
                ret.valueFields.add(moved);
            }
        }

        // 如果没有key tag,则使用第一个非repeated\非message字段
        if (ret.keyFields.size() <= 1) {
            ret.keyFields.clear();
            ret.nameType = NAME_TYPE.STRING;
        }

        return ret;
    }

    private final void writeCodeHeaderFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        if (globalCodeWrittenCache.contains(codeInfo.header)) {
            return;
        }
        globalCodeWrittenCache.add(codeInfo.header);

        // 加载代码
        FileOutputStream headerFs = createCodeHeaderFileStream(rule, codeInfo);

        HashSet<String> dumpedFields = null;
        if (isRecursiveEnabled()) {
            dumpedFields = new HashSet<String>();
        }

        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper desc_wraper = rule.keyFields.get(i);
            DataDstWriterNode node = desc_wraper.GetWriterNode(0);
            if (null == node) {
                continue;
            }

            if (null != dumpedFields) {
                dumpedFields.add(desc_wraper.varName);
            }

            writeCodeHeaderField(headerFs, node.getTypeDescriptor(), node.getFieldDescriptor(), desc_wraper.varName,
                    desc_wraper.isList, desc_wraper.isGenerated);
        }

        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper desc_wraper = rule.valueFields.get(i);
            DataDstWriterNode node = desc_wraper.GetWriterNode(0);
            if (null == node) {
                continue;
            }

            if (null != dumpedFields) {
                dumpedFields.add(desc_wraper.varName);
            }

            writeCodeHeaderField(headerFs, node.getTypeDescriptor(), node.getFieldDescriptor(), desc_wraper.varName,
                    desc_wraper.isList, desc_wraper.isGenerated);
        }

        // 如果开启了嵌套模式，还要补全未使用的字段
        if (isRecursiveEnabled() && null != codeInfo.desc) {
            for (HashMap.Entry<String, DataDstFieldDescriptor> varPair : codeInfo.desc.getTypeDescriptor().fields
                    .entrySet()) {
                String varName = getIdentName(varPair.getKey());
                if (dumpedFields.contains(varName)) {
                    continue;
                }
                dumpedFields.add(varName);

                writeCodeHeaderField(headerFs, varPair.getValue().getTypeDescriptor(), varPair.getValue(), varName,
                        varPair.getValue().isList(), false);
            }
        }

        headerFs.write(dumpString(codeHeaderSuffix));

        if (rule.helper == null || rule.helper.isEmpty()) {
            headerFs.close();
            return;
        }

        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        // 辅助代码类定义
        String helperClazzName = getIdentName(codeInfo.baseName + "_" + rule.helper);
        headerFs.write(dumpString("UCLASS(Blueprintable, BlueprintType)\r\n"));
        headerFs.write(dumpString(String.format("class U%s : public UObject\r\n", helperClazzName)));
        headerFs.write(dumpString("{\r\n"));
        headerFs.write(dumpString("    GENERATED_BODY()\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("public:\r\n"));
        headerFs.write(dumpString(String.format("    U%s();\r\n", helperClazzName)));
        headerFs.write(dumpString("\r\n"));

        if (!rule.keyFields.isEmpty()) {
            headerFs.write(dumpString("    void OnReload();\r\n"));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(
                    String.format("    static FName GetRowName(%s);\r\n", getDataRowKeyToNameParamsSpecify(rule))));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(
                    String.format("    FName GetDataRowName(%s) const;\r\n", getDataRowKeyToNameParamsSpecify(rule))));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(
                    String.format("    FName GetTableRowName(const %s& TableRow) const;\r\n", codeInfo.clazzName)));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(
                    String.format("    const %s& GetDataRowByName(const FName& Name, bool& IsValid) const;\r\n",
                            codeInfo.clazzName)));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString(String.format("    const %s& GetDataRowByKey(%s, bool& IsValid) const;\r\n",
                    codeInfo.clazzName, getDataRowKeyToNameParamsSpecify(rule))));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(String.format(
                    "    bool ForeachRow(TFunctionRef<void (const FName& Key, const %s& Value)> Predicate) const;\r\n",
                    codeInfo.clazzName)));
            headerFs.write(dumpString("\r\n"));

            headerFs.write(dumpString(getHeaderFieldUFunction()));
            headerFs.write(dumpString("    UDataTable* GetRawDataTable(bool& IsValid) const;\r\n"));
            headerFs.write(dumpString("\r\n"));
        }

        headerFs.write(dumpString(String.format("    static void ClearRow(%s& TableRow);\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    void ClearDataRow(%s& TableRow) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("private:\r\n"));
        if (!rule.keyFields.isEmpty()) {
            headerFs.write(dumpString("    TSharedPtr<ConstructorHelpers::FObjectFinder<UDataTable> > Loader;\r\n"));
            headerFs.write(dumpString("    UDataTable* DataTable;\r\n"));
        }
        headerFs.write(dumpString(String.format("    %s Empty;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("};\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.close();
    }

    private final void writeCodeSourceFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        if (globalCodeWrittenCache.contains(codeInfo.source)) {
            return;
        }
        globalCodeWrittenCache.add(codeInfo.source);

        FileOutputStream sourceFs = createCodeSourceFileStream(rule, codeInfo);

        if (rule.helper == null || rule.helper.isEmpty()) {
            sourceFs.close();
            return;
        }

        String varIsValidName = "IsValid";
        boolean varIsValidCheck = true;
        while (varIsValidCheck) {
            varIsValidCheck = false;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                if (rule.keyFields.get(i).varName.equalsIgnoreCase(varIsValidName)) {
                    varIsValidName = varIsValidName + "DTR";
                    varIsValidCheck = true;
                }
            }
        }

        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        // 辅助代码类实现
        String helperClazzName = getIdentName(codeInfo.baseName + "_" + rule.helper);
        String helperDestination;
        if (codeInfo.destinationPath.isEmpty()) {
            helperDestination = codeInfo.baseName;
        } else {
            helperDestination = String.format("%s/%s", codeInfo.destinationPath, codeInfo.baseName);
        }

        // constructor
        sourceFs.write(dumpString(String.format("U%s::U%s() : Super()\r\n", helperClazzName, helperClazzName)));
        sourceFs.write(dumpString("{\r\n"));
        // 初始化Empty
        sourceFs.write(dumpString(String.format("    U%s::ClearRow(this->Empty);\r\n", helperClazzName)));
        if (!rule.keyFields.isEmpty()) {
            sourceFs.write(dumpString(String.format(
                    "    this->Loader = MakeShareable(new ConstructorHelpers::FObjectFinder<UDataTable>(TEXT(\"DataTable'/Game/%s'\")));\r\n",
                    helperDestination)));
            // 初始化事件监听
            sourceFs.write(dumpString("    if (this->Loader && this->Loader->Succeeded())\r\n"));
            sourceFs.write(dumpString("    {\r\n"));
            sourceFs.write(dumpString("        this->DataTable = this->Loader->Object;\r\n"));
            sourceFs.write(dumpString(
                    String.format("        this->DataTable->OnDataTableChanged().AddUObject(this, &U%s::OnReload);\r\n",
                            helperClazzName)));
            sourceFs.write(dumpString("        OnReload();\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("    else\r\n"));
            sourceFs.write(dumpString("    {\r\n"));
            sourceFs.write(dumpString("        this->DataTable = nullptr;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
        }
        sourceFs.write(dumpString("}\r\n\r\n"));

        if (!rule.keyFields.isEmpty()) {
            // OnReload()
            sourceFs.write(dumpString(String.format("void U%s::OnReload()\r\n", helperClazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString("    // TODO Rebuild Index\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetRowName(...)
            sourceFs.write(dumpString(String.format("FName U%s::GetRowName(%s)\r\n", helperClazzName,
                    getDataRowKeyToNameParamsSpecify(rule))));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return %s;\r\n", getDataRowKeyToNameExpression(rule))));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetDataRowName(...)
            sourceFs.write(dumpString(String.format("FName U%s::GetDataRowName(%s) const\r\n", helperClazzName,
                    getDataRowKeyToNameParamsSpecify(rule))));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return U%s::GetRowName(%s);\r\n", helperClazzName,
                    getDataRowKeyToNameParamsPass(rule, ""))));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetTableRowName(const T& TableRow)
            sourceFs.write(dumpString(String.format("FName U%s::GetTableRowName(const %s& TableRow) const\r\n",
                    helperClazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return GetDataRowName(%s);\r\n",
                    getDataRowKeyToNameParamsPass(rule, "TableRow."))));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetTableRowName(const T& TableRow)
            sourceFs.write(
                    dumpString(String.format("const %s& U%s::GetDataRowByName(const FName& Name, bool& %s) const\r\n",
                            codeInfo.clazzName, helperClazzName, varIsValidName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
            sourceFs.write(dumpString("        return this->Empty;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString("    FString Context;\r\n"));
            sourceFs.write(
                    dumpString(String.format("    %s* LookupRow = DataTable->FindRow<%s>(Name, Context, false);\r\n",
                            codeInfo.clazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("    if (!LookupRow) {\r\n"));
            sourceFs.write(dumpString("        return this->Empty;\r\n"));
            sourceFs.write(dumpString("    };\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString(String.format("    %s = true;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    return *LookupRow;\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetDataRowByKey(..., bool& IsValid)
            sourceFs.write(dumpString(String.format("const %s& U%s::GetDataRowByKey(%s, bool& %s) const\r\n",
                    codeInfo.clazzName, helperClazzName, getDataRowKeyToNameParamsSpecify(rule), varIsValidName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    return GetDataRowByName(GetDataRowName(%s), %s);\r\n",
                    getDataRowKeyToNameParamsPass(rule, ""), varIsValidName)));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // ForeachRow(TFunctionRef<void (const FName& Key, const T& Value)> Predicate)
            sourceFs.write(dumpString(String.format(
                    "bool U%s::ForeachRow(TFunctionRef<void (const FName& Key, const %s& Value)> Predicate) const\r\n",
                    helperClazzName, codeInfo.clazzName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
            sourceFs.write(dumpString("        return false;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString("    FString Context;\r\n"));
            sourceFs.write(dumpString("    this->DataTable->ForeachRow(Context, Predicate);\r\n"));
            sourceFs.write(dumpString("    return true;\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));

            // GetRawDataTable(bool& IsValid)
            sourceFs.write(dumpString(String.format("UDataTable* U%s::GetRawDataTable(bool& %s) const\r\n",
                    helperClazzName, varIsValidName)));
            sourceFs.write(dumpString("{\r\n"));
            sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
            sourceFs.write(dumpString("        return NULL;\r\n"));
            sourceFs.write(dumpString("    }\r\n"));
            sourceFs.write(dumpString("\r\n"));
            sourceFs.write(dumpString(String.format("    %s = true;\r\n", varIsValidName)));
            sourceFs.write(dumpString("    return this->DataTable;\r\n"));
            sourceFs.write(dumpString("}\r\n\r\n"));
        }

        // static void ClearDataRow(const %s& TableRow);
        sourceFs.write(
                dumpString(String.format("void U%s::ClearRow(%s& TableRow)\r\n", helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        HashSet<String> dumpedFields = null;
        if (isRecursiveEnabled()) {
            dumpedFields = new HashSet<String>();
        }
        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
            DataDstWriterNode node = wrapper.GetWriterNode(0);
            if (null == node || null == node.getFieldDescriptor()) {
                continue;
            }
            writeUETypeSetDefaultCode(sourceFs, "    TableRow", wrapper.varName, node.getFieldDescriptor(),
                    wrapper.isList);
            if (null != dumpedFields) {
                dumpedFields.add(wrapper.varName);
            }
        }
        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.valueFields.get(i);
            DataDstWriterNode node = wrapper.GetWriterNode(0);
            if (null == node || null == node.getFieldDescriptor()) {
                continue;
            }
            writeUETypeSetDefaultCode(sourceFs, "    TableRow", wrapper.varName, node.getFieldDescriptor(),
                    wrapper.isList);
            if (null != dumpedFields) {
                dumpedFields.add(wrapper.varName);
            }
        }
        // 如果开启了嵌套模式，还要补全未使用的字段，因为可能被别处用到
        if (isRecursiveEnabled() && null != codeInfo.desc) {
            for (HashMap.Entry<String, DataDstFieldDescriptor> varPair : codeInfo.desc.getTypeDescriptor().fields
                    .entrySet()) {
                String varName = getIdentName(varPair.getKey());
                if (dumpedFields.contains(varName)) {
                    continue;
                }
                dumpedFields.add(varName);

                writeUETypeSetDefaultCode(sourceFs, "    TableRow", getIdentName(varPair.getKey()), varPair.getValue(),
                        varPair.getValue().isList());
            }
        }
        sourceFs.write(dumpString("}\r\n\r\n"));

        // void ClearDataRow(const %s& TableRow) const;
        sourceFs.write(dumpString(
                String.format("void U%s::ClearDataRow(%s& TableRow) const\r\n", helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    U%s::ClearRow(TableRow);\r\n", helperClazzName)));
        sourceFs.write(dumpString("}\r\n\r\n"));
        sourceFs.close();
    }
}
