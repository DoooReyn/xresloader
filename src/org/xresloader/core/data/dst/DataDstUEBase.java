package org.xresloader.core.data.dst;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.regex.Pattern;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;
import org.xresloader.core.ProgramOptions;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstChildrenNode;
import org.xresloader.core.data.err.ConvException;
import org.xresloader.core.data.src.DataContainer;
import org.xresloader.core.data.src.DataSrcImpl;
import org.xresloader.core.engine.IdentifyEngine;
import org.xresloader.core.scheme.SchemeConf;

/**
 * Created by owentou on 2019/04/08.
 */
public abstract class DataDstUEBase extends DataDstImpl {
    static private Pattern fileToClassMatcher = Pattern.compile("[" + Pattern.quote(".-()_") + "\\s]");

    static private String codeHeaderPrefixGuard = String.join("\r\n",
            "// This file is generated by xresloader, please don't edit it.", "", "#pragma once", "");

    static private String codeHeaderPrefix1 = String.join("\r\n", "", "#include \"CoreMinimal.h\"",
            "#include \"UObject/ConstructorHelpers.h\"", "#include \"Engine/DataTable.h\"", "");
    static private String codeHeaderIncludeGenerated = "#include \"%s.generated.h\"";
    static private String codeHeaderPrefix2 = String.join("\r\n", "", "", "", "USTRUCT(BlueprintType)", "");
    static private String codeHeaderClassName = "struct F%s : public FTableRowBase";
    static private String codeHeaderPrefix3 = String.join("\r\n", "", "{", "    GENERATED_USTRUCT_BODY()", "",
            "    // Start of fields");
    static private String codeHeaderSuffix = "\r\n};";

    static private String codeSourceInclude = "#include \"%s.h\"";
    static private String ueImportFile = "UnreaImportSettings.json";

    private Charset encodingCache = null;
    private String headerFieldUProperty = null;
    private String headerFieldUFunction = null;

    public enum NAME_TYPE {
        LONG, STRING, DOUBLE
    }

    public class UEDataRowRule {
        public String helper = null;
        public String description = null;
        public NAME_TYPE nameType = NAME_TYPE.LONG;
        public ArrayList<DataDstWriterNodeWrapper> keyFields = null;
        public ArrayList<DataDstWriterNodeWrapper> valueFields = null;
    }

    @Override
    public boolean init() {
        encodingCache = null;
        headerFieldUProperty = null;
        return true;
    }

    /**
     * @return 协议处理器名字
     */
    public String name() {
        return "ue";
    }

    public class UECodeInfo {
        public String header = null;
        public String source = null;
        public String outputFile = null;
        public String outputDir = null;
        public String headerDir = null;
        public String sourceDir = null;
        public String includeDir = null;
        public String clazzName = null;
        public String bashName = null;
        public String category = null;
        public String destinationPath = null;
    }

    public class DataDstWriterNodeWrapper implements Comparable<DataDstWriterNodeWrapper> {
        public String varName = null;
        public DataDstWriterNode desc = null;
        public Boolean isGenerated = false;

        @Override
        public int compareTo(DataDstWriterNodeWrapper r) {
            int lv = 0;
            if (desc.identify != null) {
                lv = desc.identify.index;
            }
            int rv = 0;
            if (r.desc.identify != null) {
                rv = r.desc.identify.index;
            }
            return lv - rv;
        }
    }

    static public String getIdentName(String in) {
        String[] segs = fileToClassMatcher.split(in);
        if (SchemeConf.getInstance().getUECSVOptions().enableCaseConvert) {
            for (int i = 0; i < segs.length; ++i) {
                if (!segs[i].isEmpty() && Character.isLowerCase(segs[i].charAt(0))) {
                    segs[i] = Character.toUpperCase(segs[i].charAt(0)) + segs[i].substring(1);
                }
            }

            return String.join("", segs);
        } else {
            return String.join("_", segs);
        }
    }

    public UECodeInfo getCodeInfo(String outputFile, String clazzName) throws IOException {
        UECodeInfo ret = new UECodeInfo();

        File ofd = new File(outputFile);
        ret.outputFile = ofd.getCanonicalFile().getAbsolutePath();
        ret.outputDir = ofd.getParentFile().getCanonicalFile().getAbsolutePath();

        // redirect header directory and source directory
        String codeOutputDir = SchemeConf.getInstance().getUECSVOptions().codeOutputDir;
        if (codeOutputDir.isEmpty()) {
            codeOutputDir = (new File(ProgramOptions.getInstance().outputDirectory)).getCanonicalFile()
                    .getAbsolutePath();
        }

        if (SchemeConf.getInstance().getUECSVOptions().category.isEmpty()) {
            ret.category = "DataTable";
        } else {
            ret.category = SchemeConf.getInstance().getUECSVOptions().category;
        }

        if (!SchemeConf.getInstance().getUECSVOptions().codeOutputPublicDir.isEmpty()) {
            String pubDir = SchemeConf.getInstance().getUECSVOptions().codeOutputPublicDir;
            ret.headerDir = codeOutputDir + File.separator + pubDir;
            if (pubDir.charAt(0) == '/' || pubDir.charAt(0) == '\\') {
                pubDir = pubDir.substring(1);
            }

            if (pubDir.substring(0, 7).equalsIgnoreCase("Public/")) {
                ret.includeDir = pubDir.substring(7).replace('\\', '/');
            } else {
                ret.includeDir = pubDir.replace('\\', '/');
            }

            if (!ret.includeDir.isEmpty() && !ret.includeDir.endsWith("/")) {
                ret.includeDir = ret.includeDir + "/";
            }
        } else {
            ret.headerDir = codeOutputDir;
            ret.includeDir = "";
        }

        if (!SchemeConf.getInstance().getUECSVOptions().codeOutputPrivateDir.isEmpty()) {
            ret.sourceDir = codeOutputDir + File.separator
                    + SchemeConf.getInstance().getUECSVOptions().codeOutputPrivateDir;
        } else {
            ret.sourceDir = codeOutputDir;
        }

        if (clazzName == null || clazzName.isEmpty()) {
            String fileName = ofd.getName();
            int lastDot = fileName.lastIndexOf('.');
            if (lastDot < 0) {
                ret.bashName = outputFile;
            } else {
                ret.bashName = fileName.substring(0, lastDot);
            }
        } else {
            ret.bashName = clazzName;
        }
        ret.clazzName = getIdentName(ret.bashName);

        ret.header = ret.headerDir + File.separator + ret.clazzName + ".h";
        ret.source = ret.sourceDir + File.separator + ret.clazzName + ".cpp";

        ret.destinationPath = "DataTable";
        if (ret.includeDir.length() > 1) {
            ret.destinationPath = String.format("%s", ret.includeDir.substring(0, ret.includeDir.length() - 1));
        }

        return ret;
    }

    public void writeImportSettings(UECodeInfo code) {
        File importFile = new File(code.outputDir + File.separator + ueImportFile);
        if (!importFile.getParentFile().exists()) {
            importFile.getParentFile().mkdirs();
        }

        JSONObject importObj;
        JSONArray groupObj;

        if (importFile.exists()) {
            try {
                importObj = new JSONObject(new JSONTokener(new FileInputStream(importFile)));
            } catch (JSONException | FileNotFoundException e) {
                importObj = new JSONObject();
                ProgramOptions.getLoger().error("Read json from %s failed, %s", importFile.getAbsolutePath(),
                        e.getMessage());
            }
        } else {
            importObj = new JSONObject();
        }

        try {
            if (importObj.has("ImportGroups")) {
                groupObj = importObj.getJSONArray("ImportGroups");
            } else {
                groupObj = new JSONArray();
                importObj.put("ImportGroups", groupObj);
            }

            JSONObject selectedItem = null;
            for (int i = 0; i < groupObj.length(); ++i) {
                JSONObject item = groupObj.getJSONObject(i);
                if (item.has("ImportSettings")) {
                    if (item.getJSONObject("ImportSettings").optString("ImportRowStruct").equals(code.clazzName)) {
                        selectedItem = item;
                        break;
                    }
                }
            }

            if (null == selectedItem) {
                selectedItem = new JSONObject();
                groupObj.put(selectedItem);
            }

            selectedItem.put("GroupName", code.category);

            JSONArray dataFileList = new JSONArray();
            dataFileList.put(code.outputFile);
            selectedItem.put("Filenames", dataFileList);
            selectedItem.put("DestinationPath", code.destinationPath);
            selectedItem.put("bReplaceExisting", "true");
            selectedItem.put("bSkipReadOnly", "true");
            selectedItem.put("FactoryName", "ReimportDataTableFactory");

            JSONObject importSetting = null;
            if (selectedItem.has("ImportSettings")) {
                importSetting = selectedItem.getJSONObject("ImportSettings");
            } else {
                importSetting = new JSONObject();
                selectedItem.put("ImportSettings", importSetting);
            }

            importSetting.put("ImportRowStruct", code.clazzName);
            importSetting.put("ImportType", "ECSV_DataTable");

            FileOutputStream fos = new FileOutputStream(importFile, false);
            fos.write(dumpString(importObj.toString(4)));
            fos.close();
        } catch (Exception e) {
            ProgramOptions.getLoger().error("Write json to %s failed, %s", importFile.getAbsolutePath(),
                    e.getMessage());
        }
    }

    private byte[] dumpString(String in) {
        if (null != encodingCache) {
            return in.getBytes(encodingCache);
        }

        // 带编码的输出
        String encoding = SchemeConf.getInstance().getKey().getEncoding();
        if (null == encoding || encoding.isEmpty())
            return in.toString().getBytes();

        encodingCache = Charset.forName(encoding);
        return in.getBytes(encodingCache);
    }

    public FileOutputStream createCodeHeaderFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.header);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.header, false);
        fos.write(dumpString(codeHeaderPrefixGuard));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
        }
        fos.write(dumpString(codeHeaderPrefix1));
        fos.write(dumpString(String.format(codeHeaderIncludeGenerated, code.clazzName)));
        fos.write(dumpString(codeHeaderPrefix2));
        fos.write(dumpString(String.format(codeHeaderClassName, code.clazzName)));
        fos.write(dumpString(codeHeaderPrefix3));

        return fos;
    }

    public FileOutputStream createCodeSourceFileStream(UEDataRowRule rule, UECodeInfo code) throws IOException {
        File ofd = new File(code.source);
        File parentFile = ofd.getParentFile();
        if (!parentFile.exists()) {
            parentFile.mkdirs();
        }

        FileOutputStream fos = new FileOutputStream(code.source, false);
        fos.write(dumpString("// This file is generated by xresloader, please don't edit it.\r\n\r\n"));
        if (null != rule && null != rule.description) {
            for (String descLine : rule.description.replace("\r\n", "\n").replace("\r", "\n").split("\n")) {
                fos.write(dumpString(String.format("// %s\r\n", descLine)));
            }
            fos.write(dumpString("\r\n"));
        }

        fos.write(dumpString(String.format(codeSourceInclude, code.includeDir + code.clazzName)));

        return fos;
    }

    @Override
    public final byte[] build(DataDstImpl compiler) throws ConvException {
        // DataDstJava.DataDstObject data_obj = build_data(compiler);
        Object buildObj = null;

        try {
            buildObj = buildForUEOnInit();

            build_data(buildObj, compiler);
        } catch (IOException e) {
            throw new ConvException(String.format("build data for %s failed. msg: %s", name(), e.getMessage()));
        }

        return buildForUEOnFinal(buildObj);
    }

    abstract protected Object buildForUEOnInit() throws IOException;

    abstract protected byte[] buildForUEOnFinal(Object buildObj);

    abstract protected void buildForUEOnPrintHeader(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule)
            throws IOException;

    abstract protected void buildForUEOnPrintRecord(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule)
            throws IOException;

    protected final void build_data(Object buildObj, DataDstImpl compiler) throws ConvException, IOException {
        while (DataSrcImpl.getOurInstance().next_table()) {
            // 生成描述集
            DataDstWriterNode desc = compiler.compile();

            String originClazzName;
            if (desc.packageName == null || desc.packageName.isEmpty()) {
                originClazzName = SchemeConf.getInstance().getProtoName();
            } else {
                originClazzName = desc.packageName + "_" + SchemeConf.getInstance().getProtoName();
            }
            UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), originClazzName);

            // 生成描述集,CSV必须固定化描述集，还要把字段平铺开来。
            ArrayList<DataDstWriterNodeWrapper> expandedDesc = new ArrayList<DataDstWriterNodeWrapper>();
            expandedDesc.ensureCapacity(32);
            expandDescription(expandedDesc, desc, "");

            if (expandedDesc.isEmpty()) {
                continue;
            }

            // ======================================================================================================
            UEDataRowRule rule = splitDataRowDesc(expandedDesc);
            rule.helper = desc.mutableExtension().mutableUE().helper;
            rule.description = desc.mutableExtension().description;
            // ======================================================================================================

            // 输出header
            ArrayList<Object> row_data = new ArrayList<Object>();
            row_data.ensureCapacity(rule.keyFields.size() + rule.valueFields.size());
            for (int i = 0; i < rule.keyFields.size(); ++i) {
                row_data.add(rule.keyFields.get(i).varName);
            }
            for (int i = 0; i < rule.valueFields.size(); ++i) {
                row_data.add(rule.valueFields.get(i).varName);
            }
            buildForUEOnPrintHeader(buildObj, row_data, rule);

            // 输出数据
            while (DataSrcImpl.getOurInstance().next_row()) {
                row_data = new ArrayList<Object>();
                row_data.ensureCapacity(rule.keyFields.size() + rule.valueFields.size());

                // 先用特殊规则导入Name字段,Name字段可能是合成字段
                row_data.add(pickNameField(rule));
                for (int i = 1; i < rule.keyFields.size(); ++i) {
                    row_data.add(pickValueField(rule.keyFields.get(i).desc));
                }
                for (int i = 0; i < rule.valueFields.size(); ++i) {
                    row_data.add(pickValueField(rule.valueFields.get(i).desc));
                }
                buildForUEOnPrintRecord(buildObj, row_data, rule);
            }

            // 加载代码
            writeCodeHeaderFile(rule, codeInfo);
            writeCodeSourceFile(rule, codeInfo);

            // 写出导出文件
            writeImportSettings(codeInfo);
        }
    }

    private Object pickNameField(UEDataRowRule rule) throws ConvException {
        // 如果是直接采用原始字段则直接返回原始字段数据
        if (rule.keyFields.get(0).desc != null) {
            return pickValueField(rule.valueFields.get(0).desc);
        }

        switch (rule.nameType) {
        case LONG: {
            long ret = 0;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNode desc = rule.keyFields.get(i).desc;
                Object val = pickValueField(desc);
                if (val instanceof Number) {
                    ret = ret + desc.identify.mutableExtension().mutableUE().keyTag * ((Number) val).longValue();
                } else {
                    ret = ret + desc.identify.mutableExtension().mutableUE().keyTag
                            * Long.valueOf(pickValueField(rule.keyFields.get(i).desc).toString());
                }
            }

            return ret;
        }
        case DOUBLE: {
            double ret = 0.0;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNode desc = rule.keyFields.get(i).desc;
                Object val = pickValueField(desc);
                if (val instanceof Number) {
                    ret = ret + desc.identify.mutableExtension().mutableUE().keyTag * ((Number) val).doubleValue();
                } else {
                    ret = ret + desc.identify.mutableExtension().mutableUE().keyTag
                            * Double.valueOf(pickValueField(rule.keyFields.get(i).desc).toString());
                }
            }

            return ret;
        }
        case STRING: {
            ArrayList<String> ls = new ArrayList<String>();
            ls.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                ls.add(pickValueField(rule.keyFields.get(i).desc).toString());
            }

            return String.join("", ls);
        }
        default:
            return 0;
        }
    }

    private Object pickValueField(DataDstWriterNode desc) throws ConvException {
        if (null == desc.identify || desc.getType() == DataDstWriterNode.JAVA_TYPE.MESSAGE) {
            return false;
        }

        switch (desc.getType()) {
        case INT: {
            DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
            if (null != ret && ret.valid) {
                return ret.value.intValue();
            }
            break;
        }

        case LONG: {
            DataContainer<Long> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0L);
            if (null != ret && ret.valid) {
                return ret.value.longValue();
            }
            break;
        }

        case FLOAT: {
            DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
            if (null != ret && ret.valid) {
                return ret.value.floatValue();
            }
            break;
        }

        case DOUBLE: {
            DataContainer<Double> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, 0.0);
            if (null != ret && ret.valid) {
                return ret.value.doubleValue();
            }
            break;
        }

        case BOOLEAN: {
            DataContainer<Boolean> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, false);
            if (null != ret && ret.valid) {
                return ret.value.booleanValue();
            }
            break;
        }

        case STRING: {
            DataContainer<String> ret = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
            if (null != ret && ret.valid) {
                return ret.value;
            }
            break;
        }

        case BYTES: {
            DataContainer<String> res = DataSrcImpl.getOurInstance().getValue(desc.identify, "");
            if (null != res && res.valid) {
                String encoding = SchemeConf.getInstance().getKey().getEncoding();
                if (null == encoding || encoding.isEmpty()) {
                    return Base64.getEncoder().encodeToString(res.value.getBytes());
                } else {
                    return Base64.getEncoder().encodeToString(res.value.getBytes(Charset.forName(encoding)));
                }
            }
            break;
        }

        case MESSAGE: {
            break;
        }
        default:
            break;
        }

        return null;
    }

    protected void expandDescription(ArrayList<DataDstWriterNodeWrapper> descs, DataDstWriterNode desc, String prefix) {
        boolean isLeaf = true;
        switch (desc.getType()) {
        case INT: {
            break;
        }
        case LONG: {
            break;
        }
        case BOOLEAN: {
            break;
        }
        case STRING: {
            break;
        }
        case BYTES: {
            break;
        }
        case FLOAT: {
            break;
        }
        case DOUBLE: {
            break;
        }
        case MESSAGE: {
            isLeaf = false;
            for (HashMap.Entry<String, DataDstChildrenNode> child : desc.getChildren().entrySet()) {
                String varName = getIdentName(child.getKey());
                if (child.getValue().isList) {
                    for (int i = 0; i < child.getValue().nodes.size(); ++i) {
                        DataDstWriterNode child_desc = child.getValue().nodes.get(i);
                        expandDescription(descs, child_desc, prefix + String.format("_%s_%d", varName, i));
                    }
                } else if (!child.getValue().nodes.isEmpty()) {
                    expandDescription(descs, child.getValue().nodes.get(0), prefix + "_" + varName);
                }
            }
            break;
        }
        }

        if (!isLeaf) {
            return;
        }

        DataDstWriterNodeWrapper res = new DataDstWriterNodeWrapper();
        res.varName = prefix.substring(1);
        res.desc = desc;
        descs.add(res);
    }

    /**
     * 和输出格式无关的常量转储功能
     * 
     * @param data 常量数据集
     * @return 常量代码
     */
    abstract public String dumpConstForUE(HashMap<String, Object> data, UEDataRowRule rule) throws IOException;

    /**
     * 转储常量数据
     * 
     * @return 常量数据,不支持的时候返回空
     * @throws IOException
     */
    public final byte[] dumpConst(HashMap<String, Object> data) throws IOException {
        // 加载代码
        UECodeInfo codeInfo = getCodeInfo(SchemeConf.getInstance().getOutputFileAbsPath(), null);

        // const完整路径都在data里了，不需要额外的包名(可能包含多个包)
        // ======================================================================================================
        ArrayList<DataDstWriterNodeWrapper> expandedDesc = new ArrayList<DataDstWriterNodeWrapper>();
        DataDstWriterNodeWrapper constNameNode = new DataDstWriterNodeWrapper();
        constNameNode.desc = DataDstWriterNode.create(null, DataDstWriterNode.JAVA_TYPE.STRING, "");
        constNameNode.desc.identify = IdentifyEngine.n2i("Name", 0);
        constNameNode.varName = getIdentName("Name");
        constNameNode.isGenerated = true;
        expandedDesc.add(constNameNode);

        DataDstWriterNodeWrapper constValueNode = new DataDstWriterNodeWrapper();
        constValueNode.desc = DataDstWriterNode.create(null, DataDstWriterNode.JAVA_TYPE.STRING, "");
        constValueNode.desc.identify = IdentifyEngine.n2i("Value", 1);
        constValueNode.varName = getIdentName("Value");
        constValueNode.isGenerated = true;
        expandedDesc.add(constValueNode);

        UEDataRowRule constRule = splitDataRowDesc(expandedDesc);
        constRule.helper = "helper";
        constRule.nameType = NAME_TYPE.STRING;
        // ======================================================================================================

        String constCode = dumpConstForUE(data, constRule);

        // 加载代码
        writeCodeHeaderFile(constRule, codeInfo);
        writeCodeSourceFile(constRule, codeInfo);

        // 写出导出文件
        writeImportSettings(codeInfo);

        // 带编码的输出
        return dumpString(constCode);
    }

    private final String getHeaderFieldUProperty() {
        if (null == headerFieldUProperty) {
            LinkedList<String> ls = new LinkedList<String>();
            if (!SchemeConf.getInstance().getUECSVOptions().editAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUECSVOptions().editAccess);
            }

            if (!SchemeConf.getInstance().getUECSVOptions().category.isEmpty()
                    && !SchemeConf.getInstance().getUECSVOptions().blueprintAccess.isEmpty()) {
                ls.add(SchemeConf.getInstance().getUECSVOptions().blueprintAccess);
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUECSVOptions().category));
            }
            headerFieldUProperty = String.format("    UPROPERTY(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUProperty;
    }

    private final String getHeaderFieldUFunction() {
        if (null == headerFieldUFunction) {
            LinkedList<String> ls = new LinkedList<String>();

            ls.add("BlueprintCallable");
            if (!SchemeConf.getInstance().getUECSVOptions().category.isEmpty()) {
                ls.add(String.format("Category = \"%s\"", SchemeConf.getInstance().getUECSVOptions().category));
            }
            headerFieldUFunction = String.format("    UFUNCTION(%s)\r\n", String.join(", ", ls));
        }

        return headerFieldUFunction;
    }

    private final String getDataRowKeyToNameParamsSpecify(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.desc != null) {
            String ueTypeName = getUETypeName(nameNode.desc.getType());
            if (ueTypeName.equalsIgnoreCase("FString")) {
                ueTypeName = "FName";
            }
            return String.format("%s %s", ueTypeName, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s %s", getUETypeName(keyNode.desc.getType()), keyNode.varName));
        }

        return String.join(", ", params);
    }

    private final String getDataRowKeyToNameParamsPass(UEDataRowRule rule, String prefix) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        if (null == prefix) {
            prefix = "";
        }
        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.desc != null) {
            return String.format("%s%s", prefix, nameNode.varName);
        }

        ArrayList<String> params = new ArrayList<String>();
        params.ensureCapacity(rule.keyFields.size());
        for (int i = 1; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
            params.add(String.format("%s%s", prefix, keyNode.varName));
        }

        return String.join(", ", params);
    }

    /**
     * @see pickNameField
     * @param rule
     * @return
     */
    private final String getDataRowKeyToNameExpression(UEDataRowRule rule) {
        if (null == rule || null == rule.keyFields) {
            return "";
        }

        if (rule.keyFields.isEmpty()) {
            return "";
        }

        DataDstWriterNodeWrapper nameNode = rule.keyFields.get(0);
        if (nameNode.desc != null) {
            String ueTypeNameIdent = nameNode.desc.identify.mutableExtension().mutableUE().ueTypeName;
            if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                return String.format("*%s.ToString()", nameNode.varName);
            }

            switch (rule.nameType) {
            case LONG:
                return String.format("*FString::Printf(TEXT(\"%%lld\"), static_cast<long long>(%s))", nameNode.varName);
            case DOUBLE:
                return String.format("*FString::Printf(TEXT(\"%%g\"), static_cast<double>(%s))", nameNode.varName);
            case STRING:
                return nameNode.varName;
            default:
                return "/** Error Key Set **/";
            }
        }

        switch (rule.nameType) {
        case LONG: {
            ArrayList<String> params = new ArrayList<String>();
            params.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                params.add(String.format("static_cast<long long>(%s) * %s", keyNode.varName,
                        keyNode.desc.identify.mutableExtension().mutableUE().keyTag));
            }
            return String.format("*FString::Printf(TEXT(\"%%lld\"), %s)", String.join(" + ", params));
        }
        case DOUBLE: {
            ArrayList<String> params = new ArrayList<String>();
            params.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                params.add(String.format("static_cast<double>(%s) * %s", keyNode.varName,
                        keyNode.desc.identify.mutableExtension().mutableUE().keyTag));
            }
            return String.format("*FString::Printf(TEXT(\"%%g\"), %s)", String.join(" + ", params));
        }
        case STRING: {
            ArrayList<String> paramTypes = new ArrayList<String>();
            ArrayList<String> paramValues = new ArrayList<String>();
            paramTypes.ensureCapacity(rule.keyFields.size());
            paramValues.ensureCapacity(rule.keyFields.size());
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                DataDstWriterNodeWrapper keyNode = rule.keyFields.get(i);
                String fmt = getUETypeFormat(keyNode.desc.getType());
                paramTypes.add(fmt);

                String ueTypeNameIdent = keyNode.desc.identify.mutableExtension().mutableUE().ueTypeName;
                if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
                    paramValues.add(String.format("*%s.ToString()", keyNode.varName));
                } else if (fmt.equals("%s")) {
                    paramValues.add("*" + keyNode.varName);
                } else {
                    paramValues.add(keyNode.varName);
                }
            }

            return String.format("*FString::Printf(TEXT(\"%s\"), %s)", String.join("", paramTypes),
                    String.join(", ", paramValues));
        }
        default:
            return "/** Error Key Set **/";
        }
    }

    private final void writeCodeHeaderField(FileOutputStream fout, DataDstWriterNodeWrapper nodeWraper, String varName)
            throws IOException {
        fout.write(dumpString("\r\n"));
        DataDstWriterNode.JAVA_TYPE descType = DataDstWriterNode.JAVA_TYPE.STRING;
        if (null != nodeWraper.desc) {
            descType = nodeWraper.desc.getType();
            if (null != nodeWraper.desc.identify && null != nodeWraper.desc.identify.mutableExtension().description) {
                for (String descLine : nodeWraper.desc.identify.mutableExtension().description.replace("\r\n", "\n")
                        .replace("\r", "\n").split("\n")) {
                    fout.write(dumpString(String.format("    // %s\r\n", descLine)));
                }
            }
        }

        if (nodeWraper.isGenerated) {
            fout.write(dumpString(String.format(
                    "    /** Field Type: %s, Name: %s. This field is generated for UE Editor compatible. **/\r\n",
                    descType.name(), varName)));
        } else {
            fout.write(dumpString(String.format("    /** Field Type: %s, Name: %s **/\r\n", descType.name(), varName)));
        }

        String ueTypeName = null;
        boolean enable = true;
        switch (descType) {
        case INT:
        case LONG:
        case FLOAT:
        case DOUBLE:
        case BOOLEAN:
            break;
        case STRING: {
            if (varName.equalsIgnoreCase("Name")) {
                ueTypeName = "FName";
            }
            break;
        }
        case BYTES: {
            if (varName.equalsIgnoreCase("Name")) {
                ueTypeName = "FName";
            }
            fout.write(
                    dumpString(String.format("    /** Bytes data will be encoded by base64 for %s */\r\n", varName)));
            break;
        }

        case MESSAGE: {
            enable = false;
            fout.write(dumpString(String.format("    /** invalid data type %s of UE DataTable for %s */\r\n",
                    descType.name(), varName)));
            ProgramOptions.getLoger().error("invalid data type %s of UE DataTable for %s, should not called here.",
                    descType.name(), varName);
            break;
        }

        default:
            enable = false;
            fout.write(dumpString(String.format("    /** invalid data type %s of UE DataTable for %s */\r\n",
                    descType.name(), varName)));
            ProgramOptions.getLoger().error("invalid data type %s of UE DataTable for %s, should not called here.",
                    descType.name(), varName);
            break;
        }

        if (enable) {
            if (null == ueTypeName) {
                String ueTypeNameIdent = null;
                if (null != nodeWraper.desc && null != nodeWraper.desc.identify) {
                    ueTypeNameIdent = nodeWraper.desc.identify.mutableExtension().mutableUE().ueTypeName;
                }
                if (ueTypeNameIdent == null || ueTypeNameIdent.isEmpty()) {
                    ueTypeName = getUETypeName(descType);
                } else {
                    ueTypeName = String.format("TSoftObjectPtr<%s>", ueTypeNameIdent);
                }
            }
            fout.write(dumpString(getHeaderFieldUProperty()));
            fout.write(dumpString(String.format("    %s %s;\r\n", ueTypeName, varName)));
        }
    }

    private final String getUETypeName(DataDstWriterNode.JAVA_TYPE type) {
        switch (type) {
        case INT:
            return "int32";
        case LONG:
            return "int64";
        case FLOAT:
            return "float";
        case DOUBLE:
            return "double";
        case BOOLEAN:
            return "bool";
        case STRING:
            return "FString";
        case BYTES:
            return "FString";
        case MESSAGE:
            return "";
        default:
            return "";
        }
    }

    private final String getUETypeDefault(DataDstWriterNodeWrapper wrapper) {
        DataDstWriterNode.JAVA_TYPE descType = DataDstWriterNode.JAVA_TYPE.STRING;
        String ueTypeNameIdent = null;

        if (null != wrapper.desc) {
            descType = wrapper.desc.getType();

            if (null != wrapper.desc.identify) {
                ueTypeNameIdent = wrapper.desc.identify.mutableExtension().mutableUE().ueTypeName;
            }
        }

        if (ueTypeNameIdent != null && !ueTypeNameIdent.isEmpty()) {
            return "nullptr";
        }

        switch (descType) {
        case INT:
            return "0";
        case LONG:
            return "0";
        case FLOAT:
            return "0";
        case DOUBLE:
            return "0";
        case BOOLEAN:
            return "false";
        case STRING:
            return "TEXT(\"\")";
        case BYTES:
            return "TEXT(\"\")";
        case MESSAGE:
            return "nullptr";
        default:
            return "NULL";
        }
    }

    private final String getUETypeFormat(DataDstWriterNode.JAVA_TYPE type) {
        switch (type) {
        case INT:
            return "%d";
        case LONG:
            return "%lld";
        case FLOAT:
            return "%f";
        case DOUBLE:
            return "%llf";
        case BOOLEAN:
            return "%d";
        case STRING:
            return "%s";
        case BYTES:
            return "%s";
        case MESSAGE:
            return "nullptr";
        default:
            return "NULL";
        }
    }

    private final NAME_TYPE getUENameType(DataDstWriterNode desc) {
        if (null != desc.identify && null != desc.identify.mutableExtension().mutableUE().ueTypeName
                && !desc.identify.mutableExtension().mutableUE().ueTypeName.isEmpty()) {
            return NAME_TYPE.STRING;
        }

        switch (desc.getType()) {
        case INT:
            return NAME_TYPE.LONG;
        case LONG:
            return NAME_TYPE.LONG;
        case FLOAT:
            return NAME_TYPE.DOUBLE;
        case DOUBLE:
            return NAME_TYPE.DOUBLE;
        case BOOLEAN:
            return NAME_TYPE.LONG;
        case STRING:
            return NAME_TYPE.STRING;
        case BYTES:
            return NAME_TYPE.STRING;
        case MESSAGE:
            return NAME_TYPE.STRING;
        default:
            return NAME_TYPE.LONG;
        }
    }

    private final UEDataRowRule splitDataRowDesc(ArrayList<DataDstWriterNodeWrapper> expandedDesc) {
        UEDataRowRule ret = new UEDataRowRule();
        if (expandedDesc.isEmpty()) {
            return ret;
        }

        expandedDesc.sort(null);

        // UE 要求Key字段名必须是 Name，所以要查找Name的字段，没有的话要生成一个
        int nameIndex = -1;
        for (int i = 0; i < expandedDesc.size(); ++i) {
            if (expandedDesc.get(i).varName.equalsIgnoreCase("Name")) {
                nameIndex = i;
                break;
            }
        }

        // 如果字段里本来就有，就直接用原始的字段
        if (nameIndex >= 0) {
            ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
            ret.keyFields.add(expandedDesc.get(nameIndex));
            expandedDesc.remove(nameIndex);
            ret.valueFields = expandedDesc;
            ret.nameType = getUENameType(ret.keyFields.get(0).desc);
            return ret;
        }

        // 检查 key_tag，如果找到了，就优先用 key_tag
        DataDstWriterNodeWrapper namedKey = new DataDstWriterNodeWrapper();
        namedKey.varName = "Name";
        namedKey.isGenerated = true;

        ret.keyFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.keyFields.ensureCapacity(expandedDesc.size());
        ret.keyFields.add(namedKey);

        ret.valueFields = new ArrayList<DataDstWriterNodeWrapper>();
        ret.valueFields.ensureCapacity(expandedDesc.size());

        ret.nameType = NAME_TYPE.LONG;
        for (int i = 0; i < expandedDesc.size(); ++i) {
            DataDstWriterNodeWrapper moved = expandedDesc.get(i);
            if (null != moved.desc && null != moved.desc.identify
                    && moved.desc.identify.mutableExtension().mutableUE().keyTag > 0) {
                ret.keyFields.add(moved);
                switch (getUENameType(moved.desc)) {
                case LONG:
                    break;
                case DOUBLE:
                    if (ret.nameType == NAME_TYPE.LONG) {
                        ret.nameType = NAME_TYPE.DOUBLE;
                    }
                    break;
                case STRING:
                    ret.nameType = NAME_TYPE.STRING;
                    break;
                default:
                    break;
                }
            } else {
                ret.valueFields.add(moved);
            }
        }

        // 如果没有key tag，则使用第一个字段
        if (ret.keyFields.size() == 1) {
            namedKey.desc = ret.valueFields.get(0).desc;
            ret.nameType = getUENameType(namedKey.desc);
        }

        return ret;
    }

    private final void writeCodeHeaderFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        // 加载代码
        FileOutputStream headerFs = createCodeHeaderFileStream(rule, codeInfo);

        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper desc_wraper = rule.keyFields.get(i);
            writeCodeHeaderField(headerFs, desc_wraper, desc_wraper.varName);
        }

        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper desc_wraper = rule.valueFields.get(i);
            writeCodeHeaderField(headerFs, desc_wraper, desc_wraper.varName);
        }

        headerFs.write(dumpString(codeHeaderSuffix));

        if (rule.helper == null || rule.helper.isEmpty()) {
            headerFs.close();
            return;
        }

        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("\r\n"));
        // 辅助代码类定义
        String helperClazzName = getIdentName(codeInfo.clazzName + "_" + rule.helper);
        headerFs.write(dumpString("UCLASS(Blueprintable, BlueprintType)\r\n"));
        headerFs.write(dumpString(String.format("class U%s : public UObject\r\n", helperClazzName)));
        headerFs.write(dumpString("{\r\n"));
        headerFs.write(dumpString("    GENERATED_BODY()\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("public:\r\n"));
        headerFs.write(dumpString(String.format("    U%s();\r\n", helperClazzName)));
        headerFs.write(dumpString("\r\n"));
        headerFs.write(dumpString("    void OnReload();\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(
                String.format("    FName GetDataRowName(%s) const;\r\n", getDataRowKeyToNameParamsSpecify(rule))));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(
                String.format("    FName GetTableRowName(const F%s& TableRow) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format(
                "    const F%s& GetDataRowByName(const FName& Name, bool& IsValid) const;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    const F%s& GetDataRowByKey(%s, bool& IsValid) const;\r\n",
                codeInfo.clazzName, getDataRowKeyToNameParamsSpecify(rule))));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(String.format(
                "    bool ForeachRow(TFunctionRef<void (const FName& Key, const F%s& Value)> Predicate) const;\r\n",
                codeInfo.clazzName)));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString(getHeaderFieldUFunction()));
        headerFs.write(dumpString(String.format("    UDataTable* GetRawDataTable(bool& IsValid) const;\r\n")));
        headerFs.write(dumpString("\r\n"));

        headerFs.write(dumpString("private:\r\n"));
        headerFs.write(dumpString("    TSharedPtr<ConstructorHelpers::FObjectFinder<UDataTable> > Loader;\r\n"));
        headerFs.write(dumpString("    UDataTable* DataTable;\r\n"));
        headerFs.write(dumpString(String.format("    F%s Empty;\r\n", codeInfo.clazzName)));
        headerFs.write(dumpString("};\r\n"));
        headerFs.write(dumpString("\r\n"));

        headerFs.close();
    }

    private final void writeCodeSourceFile(UEDataRowRule rule, UECodeInfo codeInfo) throws IOException {
        FileOutputStream sourceFs = createCodeSourceFileStream(rule, codeInfo);

        if (rule.helper == null || rule.helper.isEmpty()) {
            sourceFs.close();
            return;
        }

        String varIsValidName = "IsValid";
        boolean varIsValidCheck = true;
        while (varIsValidCheck) {
            varIsValidCheck = false;
            for (int i = 1; i < rule.keyFields.size(); ++i) {
                if (rule.keyFields.get(i).varName.equalsIgnoreCase(varIsValidName)) {
                    varIsValidName = varIsValidName + "DTR";
                    varIsValidCheck = true;
                }
            }
        }

        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("\r\n"));
        // 辅助代码类实现
        String helperClazzName = getIdentName(codeInfo.clazzName + "_" + rule.helper);
        String helperDestination;
        if (codeInfo.destinationPath.isEmpty()) {
            helperDestination = codeInfo.clazzName;
        } else {
            helperDestination = String.format("%s/%s", codeInfo.destinationPath, codeInfo.clazzName);
        }

        // constructor
        sourceFs.write(dumpString(String.format("U%s::U%s() : Super()\r\n", helperClazzName, helperClazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format(
                "    this->Loader = MakeShareable(new ConstructorHelpers::FObjectFinder<UDataTable>(TEXT(\"DataTable'/Game/%s'\")));\r\n",
                helperDestination)));
        // 初始化Empty
        for (int i = 0; i < rule.keyFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.keyFields.get(i);
            sourceFs.write(dumpString(
                    String.format("    this->Empty.%s = %s;\r\n", wrapper.varName, getUETypeDefault(wrapper))));
        }
        for (int i = 0; i < rule.valueFields.size(); ++i) {
            DataDstWriterNodeWrapper wrapper = rule.valueFields.get(i);
            sourceFs.write(dumpString(
                    String.format("    this->Empty.%s = %s;\r\n", wrapper.varName, getUETypeDefault(wrapper))));
        }

        sourceFs.write(dumpString("    if (this->Loader && this->Loader->Succeeded())\r\n"));
        sourceFs.write(dumpString("    {\r\n"));
        sourceFs.write(dumpString("        this->DataTable = this->Loader->Object;\r\n"));
        sourceFs.write(dumpString(
                String.format("        this->DataTable->OnDataTableChanged().AddUObject(this, &U%s::OnReload);\r\n",
                        helperClazzName)));
        sourceFs.write(dumpString("        OnReload();\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("    else\r\n"));
        sourceFs.write(dumpString("    {\r\n"));
        sourceFs.write(dumpString("        this->DataTable = nullptr;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // OnReload()
        sourceFs.write(dumpString(String.format("void U%s::OnReload()\r\n", helperClazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString("    // TODO Rebuild Index\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetDataRowName(...)
        sourceFs.write(dumpString(String.format("FName U%s::GetDataRowName(%s) const\r\n", helperClazzName,
                getDataRowKeyToNameParamsSpecify(rule))));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    return %s;\r\n", getDataRowKeyToNameExpression(rule))));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetTableRowName(const T& TableRow)
        sourceFs.write(dumpString(String.format("FName U%s::GetTableRowName(const F%s& TableRow) const\r\n",
                helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(
                String.format("    return GetDataRowName(%s);\r\n", getDataRowKeyToNameParamsPass(rule, "TableRow."))));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetTableRowName(const T& TableRow)
        sourceFs.write(
                dumpString(String.format("const F%s& U%s::GetDataRowByName(const FName& Name, bool& %s) const\r\n",
                        codeInfo.clazzName, helperClazzName, varIsValidName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
        sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
        sourceFs.write(dumpString("        return this->Empty;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("    FString Context;\r\n"));
        sourceFs.write(
                dumpString(String.format("    F%s* LookupRow = DataTable->FindRow<F%s>(Name, Context, false);\r\n",
                        codeInfo.clazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("    if (!LookupRow) {\r\n"));
        sourceFs.write(dumpString("        return this->Empty;\r\n"));
        sourceFs.write(dumpString("    };\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("    return *LookupRow;\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetDataRowByKey(..., bool& IsValid)
        sourceFs.write(dumpString(String.format("const F%s& U%s::GetDataRowByKey(%s, bool& %s) const\r\n",
                codeInfo.clazzName, helperClazzName, getDataRowKeyToNameParamsSpecify(rule), varIsValidName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    return GetDataRowByName(GetDataRowName(%s), %s);\r\n",
                getDataRowKeyToNameParamsPass(rule, ""), varIsValidName)));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // ForeachRow(TFunctionRef<void (const FName& Key, const T& Value)> Predicate)
        sourceFs.write(dumpString(String.format(
                "bool U%s::ForeachRow(TFunctionRef<void (const FName& Key, const F%s& Value)> Predicate) const\r\n",
                helperClazzName, codeInfo.clazzName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
        sourceFs.write(dumpString("        return false;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString("    FString Context;\r\n"));
        sourceFs.write(dumpString("    this->DataTable->ForeachRow(Context, Predicate);\r\n"));
        sourceFs.write(dumpString("    return true;\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        // GetRawDataTable(bool& IsValid)
        sourceFs.write(dumpString(String.format("UDataTable* U%s::GetRawDataTable(bool& %s) const\r\n", helperClazzName,
                varIsValidName)));
        sourceFs.write(dumpString("{\r\n"));
        sourceFs.write(dumpString(String.format("    %s = false;\r\n", varIsValidName)));
        sourceFs.write(dumpString("    if (!this->DataTable) {\r\n"));
        sourceFs.write(dumpString("        return NULL;\r\n"));
        sourceFs.write(dumpString("    }\r\n"));
        sourceFs.write(dumpString("\r\n"));
        sourceFs.write(dumpString(String.format("    %s = true;\r\n", varIsValidName)));
        sourceFs.write(dumpString("    return this->DataTable;\r\n"));
        sourceFs.write(dumpString("}\r\n\r\n"));

        sourceFs.close();
    }
}
