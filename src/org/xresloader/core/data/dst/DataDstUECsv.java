package org.xresloader.core.data.dst;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.QuoteMode;
import org.xresloader.core.ProgramOptions;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstChildrenNode;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstFieldDescriptor;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstMessageDescriptor;
import org.xresloader.core.data.dst.DataDstWriterNode.JAVA_TYPE;
import org.xresloader.core.data.err.ConvException;
import org.xresloader.core.data.src.DataContainer;
import org.xresloader.core.data.src.DataSrcImpl;
import org.xresloader.core.engine.IdentifyDescriptor;
import org.xresloader.core.scheme.SchemeConf;

/**
 * Created by owentou on 2019/04/08.
 */
public class DataDstUECsv extends DataDstUEBase {
    /**
     * @return 协议处理器名字
     */
    public String name() {
        return "ue csv";
    }

    public void appendCommonHeader(CSVPrinter sp) throws IOException {
        sp.printComment("This file is generated by xresloader, please don't edit it.");
    }

    private class UEBuildObject {
        StringBuffer sb = null;
        CSVPrinter csv = null;
        ArrayList<DataDstWriterNodeWrapper> paddingFields = null;
        boolean hasPrintHeader = false;
    }

    @Override
    protected boolean isRecursiveEnabled() {
        return SchemeConf.getInstance().getUEOptions().enableRecursiveMode;
    }

    @Override
    protected Object buildForUEOnInit() throws IOException {
        UEBuildObject ret = new UEBuildObject();
        ret.sb = new StringBuffer();
        ret.csv = new CSVPrinter(ret.sb, CSVFormat.INFORMIX_UNLOAD_CSV.withQuoteMode(QuoteMode.ALL));

        appendCommonHeader(ret.csv);
        ret.csv.printComment(String.format("%s=%s", "xres_ver", ProgramOptions.getInstance().getVersion()));
        ret.csv.printComment(String.format("%s=%s", "data_ver", ProgramOptions.getInstance().getDataVersion()));
        ret.csv.printComment(String.format("%s=%d", "count", DataSrcImpl.getOurInstance().getRecordNumber()));
        ret.csv.printComment(String.format("%s=%s", "hash_code", "no hash code"));

        return ret;
    }

    @Override
    protected byte[] buildForUEOnFinal(Object buildObj) {
        // 带编码的输出
        String encoding = SchemeConf.getInstance().getKey().getEncoding();
        if (null == encoding || encoding.isEmpty())
            return ((UEBuildObject) buildObj).sb.toString().getBytes();

        return ((UEBuildObject) buildObj).sb.toString().getBytes(Charset.forName(encoding));
    }

    @Override
    protected void buildForUEOnPrintHeader(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException {
        if (((UEBuildObject) buildObj).hasPrintHeader) {
            return;
        }

        ((UEBuildObject) buildObj).hasPrintHeader = true;
        if (!isRecursiveEnabled()) {
            ((UEBuildObject) buildObj).csv.printRecord(rowData);
        } else {
            HashSet<String> dumpedFields = new HashSet<String>();
            ArrayList<String> finalRowData = new ArrayList<String>();
            ArrayList<DataDstWriterNodeWrapper> paddingFields = new ArrayList<DataDstWriterNodeWrapper>();
            ((UEBuildObject) buildObj).paddingFields = paddingFields;
            if (codeInfo.writerNodeWrapper != null && codeInfo.writerNodeWrapper.hasChidlren()) {
                finalRowData.ensureCapacity(codeInfo.writerNodeWrapper.getChildren().size() + 1); // 1 for additional
                                                                                                  // Name
                // field
                paddingFields.ensureCapacity(codeInfo.writerNodeWrapper.getChildren().size());
            }
            for (Object keyName : rowData) {
                dumpedFields.add(keyName.toString());
                finalRowData.add(keyName.toString());
            }

            if (codeInfo.writerNodeWrapper != null && codeInfo.writerNodeWrapper.hasChidlren()) {
                // 字段补全
                for (ArrayList<DataDstWriterNodeWrapper> child : codeInfo.writerNodeWrapper.getChildren()) {
                    if (child.isEmpty()) {
                        continue;
                    }

                    String varName = child.get(0).getVarName();
                    if (dumpedFields.contains(varName)) {
                        continue;
                    }

                    paddingFields.add(child.get(0));
                    finalRowData.add(varName);
                }
            }

            ((UEBuildObject) buildObj).csv.printRecord(finalRowData);
        }
    }

    @Override
    protected void buildForUEOnPrintRecord(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException {
        if (!isRecursiveEnabled()) {
            ((UEBuildObject) buildObj).csv.printRecord(rowData);
        } else {
            ArrayList<String> finalRowData = new ArrayList<String>();
            finalRowData.ensureCapacity(rowData.size() + ((UEBuildObject) buildObj).paddingFields.size());

            for (Object val : rowData) {
                if (val == null) {
                    finalRowData.add("");
                } else {
                    finalRowData.add(val.toString());
                }
            }

            for (DataDstWriterNodeWrapper field : ((UEBuildObject) buildObj).paddingFields) {
                StringBuffer sb = new StringBuffer();
                pickValueFieldCsvDefaultImpl(sb, field.getReferField());
                finalRowData.add(sb.toString());
            }

            ((UEBuildObject) buildObj).csv.printRecord(finalRowData);
        }
    }

    @Override
    public DataDstWriterNode compile() {
        this.logErrorMessage("UE-CSV can not be protocol description.");
        return null;
    }

    @SuppressWarnings("unchecked")
    private void writeConstData(CSVPrinter sp, Object data, String prefix) throws IOException {
        // null
        if (null == data) {
            sp.printRecord(prefix, "");
            return;
        }

        // 数字
        // 枚举值已被转为Java Long，会在这里执行
        if (data instanceof Number) {
            sp.printRecord(prefix, data);
            return;
        }

        // 布尔
        if (data instanceof Boolean) {
            sp.printRecord(prefix, ((Boolean) data) ? 1 : 0);
            return;
        }

        // 字符串&二进制
        if (data instanceof String) {
            sp.printRecord(prefix, data);
            return;
        }

        // 列表
        if (data instanceof List) {
            List<Object> ls = (List<Object>) data;
            for (int i = 0; i < ls.size(); ++i) {
                if (prefix.isEmpty()) {
                    writeConstData(sp, ls.get(i), String.format("%d", i));
                } else {
                    writeConstData(sp, ls.get(i), String.format("%s.%d", prefix, i));
                }
            }
            return;
        }

        // Hashmap
        if (data instanceof Map) {
            Map<String, Object> mp = (Map<String, Object>) data;
            ArrayList<Map.Entry<String, Object>> sorted_array = new ArrayList<Map.Entry<String, Object>>();
            sorted_array.ensureCapacity(mp.size());
            sorted_array.addAll(mp.entrySet());
            sorted_array.sort((l, r) -> {
                if (l.getValue() instanceof Integer && r.getValue() instanceof Integer) {
                    return ((Integer) l.getValue()).compareTo((Integer) r.getValue());
                }

                return l.getKey().compareTo(r.getKey());
            });

            for (Map.Entry<String, Object> item : sorted_array) {
                if (prefix.isEmpty()) {
                    writeConstData(sp, item.getValue(), String.format("%s", item.getKey()));
                } else {
                    writeConstData(sp, item.getValue(), String.format("%s.%s", prefix, item.getKey()));
                }
            }
            return;
        }

        sp.printRecord(prefix, data.toString());
    }

    /**
     * 和输出格式无关的常量转储功能
     * 
     * @param data 常量数据集
     * @return 常量代码
     */
    @Override
    public String dumpConstForUE(HashMap<String, Object> data, UEDataRowRule rule) throws IOException {
        StringBuffer sb = new StringBuffer();
        CSVPrinter csv = new CSVPrinter(sb, CSVFormat.EXCEL.withHeader(getIdentName("Name"), getIdentName("Value")));

        appendCommonHeader(csv);
        writeConstData(csv, data, "");

        return sb.toString();
    }

    @Override
    final protected Object pickValueField(Object buildObj, ArrayList<DataDstWriterNodeWrapper> fieldSet)
            throws ConvException {
        DataDstWriterNode msgDesc = getFirstWriterNode(fieldSet);
        DataDstFieldDescriptor field = getFieldDescriptor(fieldSet);
        if (msgDesc == null || field == null) {
            if (field != null) {
                StringBuffer fieldSB = new StringBuffer();
                pickValueFieldCsvDefaultImpl(fieldSB, field);
                String ret = fieldSB.toString();
                // empty list to nothing
                if (field.isList() && ret.equalsIgnoreCase("()")) {
                    ret = "";
                }
                return ret;
            }
            return "";
        }

        if (!isRecursiveEnabled()) {
            Object ret = pickValueFieldBaseStandardImpl(msgDesc);
            if (ret == null) {
                switch (field.getType()) {
                    case INT:
                    case LONG:
                    case FLOAT:
                    case DOUBLE: {
                        ret = "0";
                        break;
                    }
                    case BOOLEAN: {
                        ret = "False";
                        break;
                    }
                    default: {
                        ret = "";
                        break;
                    }
                }
            }

            return ret;
        }

        StringBuffer fieldSB = new StringBuffer();
        pickValueFieldCsvImpl(fieldSB, fieldSet,
                msgDesc.getReferBrothers().mode == DataDstWriterNode.CHILD_NODE_TYPE.PLAIN, true);
        String ret = fieldSB.toString();
        // empty list to nothing
        if (field.isList() && ret.equalsIgnoreCase("()")) {
            ret = "";
        }
        return ret;
    }

    protected void pickValueFieldCsvImpl(StringBuffer fieldSB, ArrayList<DataDstWriterNodeWrapper> fieldSet,
            boolean isPlainMode, boolean isTopLevel) throws ConvException {
        DataDstFieldDescriptor field = getFieldDescriptor(fieldSet);
        if (null == field) {
            return;
        }

        if (isPlainMode) {
            if (fieldSet.isEmpty()) {
                pickValueFieldCsvDefaultImpl(fieldSB, field);
            } else {
                pickValueFieldCsvImpl(fieldSB, fieldSet.get(0).getReferNode(), isPlainMode, isTopLevel);
            }
            return;
        }

        if (field.isList() && isRecursiveEnabled()) {
            if (fieldSet == null || fieldSet.isEmpty()) {
                pickValueFieldCsvDefaultImpl(fieldSB, field);
                return;
            }

            fieldSB.append("(");
            boolean hasListData = false;
            for (int i = 0; i < fieldSet.size(); ++i) {
                if (hasListData) {
                    fieldSB.append(",");
                }
                if (pickValueFieldCsvImpl(fieldSB, fieldSet.get(i).getReferNode(), isPlainMode, isTopLevel)) {
                    hasListData = true;
                } else {
                    if (hasListData) {
                        fieldSB.deleteCharAt(fieldSB.length() - 1);
                    }
                }
            }
            fieldSB.append(")");
        } else {
            if (fieldSet.isEmpty()) {
                pickValueFieldCsvDefaultImpl(fieldSB, field);
            }
            pickValueFieldCsvImpl(fieldSB, fieldSet.get(0).getReferNode(), isPlainMode, isTopLevel);
        }
    }

    protected boolean pickValueFieldCsvImpl(StringBuffer fieldSB, DataDstWriterNode desc, boolean isPlainMode,
            boolean isTopLevel) throws ConvException {

        if (isPlainMode) {
            pickValueFieldPlainCsvImpl(fieldSB, desc.identify, desc.getFieldDescriptor(), isTopLevel);
            return true;
        }

        // TODO dump oneof data

        if (desc.getType() == JAVA_TYPE.MESSAGE) {
            fieldSB.append("(");
            HashSet<String> dumpedFields = new HashSet<String>();

            boolean isFirst = true;
            for (HashMap.Entry<String, DataDstChildrenNode> child : desc.getChildren().entrySet()) {
                if (child.getValue().isOneof()) {
                    // TODO dump oneof data
                    continue;
                }

                if (isFirst) {
                    isFirst = false;
                } else {
                    fieldSB.append(",");
                }
                String varName = getIdentName(child.getKey());
                dumpedFields.add(varName);
                fieldSB.append(varName);
                fieldSB.append("=");

                pickValueFieldStandardCsvImpl(fieldSB, child.getValue(), isTopLevel);
            }

            // 需要补全空字段
            for (DataDstFieldDescriptor subField : desc.getTypeDescriptor().getSortedFields()) {
                String varName = getIdentName(subField.getName());
                if (dumpedFields.contains(varName)) {
                    continue;
                }

                fieldSB.append(",");
                fieldSB.append(varName);
                fieldSB.append("=");

                if (subField.isList()) {
                    fieldSB.append("()");
                } else if (subField.getType() == JAVA_TYPE.STRING || subField.getType() == JAVA_TYPE.BYTES) {
                    fieldSB.append("\"\"");
                } else {
                    pickValueFieldCsvDefaultImpl(fieldSB, subField);
                }
            }

            // TODO dump oneof data
            // for (DataDstOneofDescriptor oneof :
            // desc.getTypeDescriptor().getSortedOneofs()) {
            // }

            fieldSB.append(")");
            return true;
        }

        Object val = pickValueFieldBaseStandardImpl(desc);
        if (val == null) {
            if (desc.getFieldDescriptor() != null && desc.getFieldDescriptor().isList()) {
                // return pickValueFieldCsvDefaultImpl(fieldSB, desc.getFieldDescriptor());
                return false; // 这里是取值, List 不能追加 () 否则会出现异常数据
            } else {
                return pickValueMessageCsvDefaultImpl(fieldSB, desc.getTypeDescriptor());
            }
        } else {
            fieldSB.append(val);
            return true;
        }
    }

    protected void pickValueFieldStandardCsvImpl(StringBuffer fieldSB, DataDstChildrenNode node, boolean isTopLevel)
            throws ConvException {
        boolean isString = false;
        if (node.innerFieldDesc != null) {
            isString = node.innerFieldDesc.getType() == JAVA_TYPE.STRING
                    || node.innerFieldDesc.getType() == JAVA_TYPE.BYTES;
        } else if (!node.nodes.isEmpty()) {
            isString = node.nodes.get(0).getType() == JAVA_TYPE.STRING
                    || node.nodes.get(0).getType() == JAVA_TYPE.BYTES;
        }

        if (node.innerFieldDesc.isList()) {
            if (node.nodes.isEmpty()) {
                fieldSB.append("\"\"");
                return;
            }

            fieldSB.append("(");
            boolean hasListData = false;
            for (int i = 0; i < node.nodes.size(); ++i) {
                if (hasListData) {
                    fieldSB.append(",");
                }

                if (isString) {
                    fieldSB.append("\"");
                }
                if (pickValueFieldCsvImpl(fieldSB, node.nodes.get(i), false, false)) {
                    hasListData = true;
                    if (isString) {
                        fieldSB.append("\"");
                    }
                } else {
                    if (hasListData) {
                        fieldSB.deleteCharAt(fieldSB.length() - 1);
                    }
                    if (isString) {
                        // pop last quote
                        fieldSB.deleteCharAt(fieldSB.length() - 1);
                    }
                }
            }
            fieldSB.append(")");
        } else if (!node.nodes.isEmpty()) {
            if (isString) {
                fieldSB.append("\"");
            }
            pickValueFieldCsvImpl(fieldSB, node.nodes.get(0), false, false);
            if (isString) {
                fieldSB.append("\"");
            }
        }
    }

    protected boolean pickValueFieldPlainCsvImpl(StringBuffer fieldSB, DataDstWriterNode desc, DataDstChildrenNode node,
            boolean isTopLevel) throws ConvException {
        if (null == desc || node == null) {
            if (node.innerFieldDesc != null) {
                return pickValueFieldCsvDefaultImpl(fieldSB, node.innerFieldDesc);
            }
        }
        return pickValueFieldPlainCsvImpl(fieldSB, desc.identify, node.innerFieldDesc, isTopLevel);
    }

    protected boolean pickValueFieldPlainCsvImpl(StringBuffer fieldSB, IdentifyDescriptor ident,
            DataDstFieldDescriptor field, boolean isTopLevel) throws ConvException {
        if (null == ident || field == null) {
            if (field != null) {
                return pickValueFieldCsvDefaultImpl(fieldSB, field);
            }
            return false;
        }

        DataContainer<String> res = DataSrcImpl.getOurInstance().getValue(ident, "");
        if (null == res || !res.valid) {
            return pickValueFieldCsvDefaultImpl(fieldSB, field);
        }

        return pickValueFieldPlainCsvImpl(fieldSB, ident, field, isTopLevel, res.value);
    }

    protected boolean pickValueFieldPlainCsvImpl(StringBuffer fieldSB, IdentifyDescriptor ident,
            DataDstFieldDescriptor field, boolean isTopLevel, String input) throws ConvException {
        if (field == null) {
            // TODO oneof ?
            return false;
        }
        if ((isTopLevel && !field.isList()) && field.getType() != DataDstWriterNode.JAVA_TYPE.MESSAGE) {
            // error type
            logErrorMessage("Plain type %s of %s.%s must be list", field.getType().toString(),
                    field.getTypeDescriptor().getFullName(), field.getName());
            return false;
        }

        if (field.isList()) {
            boolean ret = false;
            String[] groups = splitPlainGroups(input.trim(), getPlainFieldSeparator(field));
            switch (field.getType()) {
                case INT: {
                    Long[] values = parsePlainDataLong(groups, ident, isTopLevel ? null : field);
                    if (null != values && values.length > 0) {
                        fieldSB.append("(");
                        boolean isFirst = true;
                        for (Long v : values) {
                            if (!isFirst) {
                                fieldSB.append(",");
                            }
                            fieldSB.append(v.intValue());
                            isFirst = false;
                        }
                        fieldSB.append(")");
                        ret = true;
                    }
                    break;
                }
                case LONG: {
                    Long[] values = parsePlainDataLong(groups, ident, isTopLevel ? null : field);
                    if (null != values && values.length > 0) {
                        fieldSB.append("(");
                        boolean isFirst = true;
                        for (Long v : values) {
                            if (!isFirst) {
                                fieldSB.append(",");
                            }
                            fieldSB.append(v);
                            isFirst = false;
                        }
                        fieldSB.append(")");
                        ret = true;
                    }
                    break;
                }

                case FLOAT: {
                    Double[] values = parsePlainDataDouble(groups, ident, isTopLevel ? null : field);
                    if (null != values && values.length > 0) {
                        fieldSB.append("(");
                        boolean isFirst = true;
                        for (Double v : values) {
                            if (!isFirst) {
                                fieldSB.append(",");
                            }
                            fieldSB.append(v.floatValue());
                            isFirst = false;
                        }
                        fieldSB.append(")");
                        ret = true;
                    }
                    break;
                }

                case DOUBLE: {
                    Double[] values = parsePlainDataDouble(groups, ident, isTopLevel ? null : field);
                    if (null != values && values.length > 0) {
                        fieldSB.append("(");
                        boolean isFirst = true;
                        for (Double v : values) {
                            if (!isFirst) {
                                fieldSB.append(",");
                            }
                            fieldSB.append(v);
                            isFirst = false;
                        }
                        fieldSB.append(")");
                        ret = true;
                    }
                    break;
                }

                case BOOLEAN: {
                    Boolean[] values = parsePlainDataBoolean(groups, ident, isTopLevel ? null : field);
                    if (null != values && values.length > 0) {
                        fieldSB.append("(");
                        boolean isFirst = true;
                        for (Boolean v : values) {
                            if (!isFirst) {
                                fieldSB.append(",");
                            }
                            if (v) {
                                fieldSB.append("True");
                            } else {
                                fieldSB.append("False");
                            }

                            isFirst = false;
                        }
                        fieldSB.append(")");
                        ret = true;
                    }
                    break;
                }

                case STRING:
                case BYTES: {
                    String[] values = parsePlainDataString(groups, ident, isTopLevel ? null : field);
                    if (null != values && values.length > 0) {
                        fieldSB.append("(");
                        boolean isFirst = true;
                        for (String v : values) {
                            if (!isFirst) {
                                fieldSB.append(",");
                            }
                            fieldSB.append("\"");
                            if (v.length() >= 2 && (v.charAt(0) == '"' || v.charAt(0) == '\'')
                                    && v.charAt(0) == v.charAt(v.length() - 1)) {
                                fieldSB.append(v.substring(1, v.length() - 1));
                            } else {
                                fieldSB.append(v);
                            }
                            fieldSB.append("\"");

                            isFirst = false;
                        }
                        fieldSB.append(")");
                        ret = true;
                    }
                    break;
                }

                case MESSAGE: {
                    boolean isFirst = true;
                    if (groups.length > 0) {
                        fieldSB.append("(");
                        for (String v : groups) {
                            String[] subGroups = splitPlainGroups(v, getPlainMessageSeparator(field));
                            if (subGroups != null && subGroups.length > 0) {
                                if (!isFirst) {
                                    fieldSB.append(",");
                                }
                                pickValueFieldCsvPlainField(fieldSB, subGroups, ident, field);
                                isFirst = false;
                            }
                        }

                        fieldSB.append(")");
                        ret = true;
                    }
                    break;
                }

                default:
                    // TODO dump oneof data
                    break;
            }

            return ret;
        } else {
            switch (field.getType()) {
                case INT: {
                    fieldSB.append(parsePlainDataLong(input.trim(), ident, isTopLevel ? null : field).intValue());
                    break;
                }

                case LONG: {
                    fieldSB.append(parsePlainDataLong(input.trim(), ident, isTopLevel ? null : field));
                    break;
                }

                case FLOAT: {
                    fieldSB.append(parsePlainDataDouble(input.trim(), ident, isTopLevel ? null : field).floatValue());
                    break;
                }

                case DOUBLE: {
                    fieldSB.append(parsePlainDataDouble(input.trim(), ident, isTopLevel ? null : field));
                    break;
                }

                case BOOLEAN: {
                    fieldSB.append(parsePlainDataBoolean(input.trim(), ident, isTopLevel ? null : field));
                    break;
                }

                case STRING:
                case BYTES: {
                    fieldSB.append("\"");
                    fieldSB.append(parsePlainDataString(input.trim(), ident, isTopLevel ? null : field));
                    fieldSB.append("\"");
                    break;
                }

                case MESSAGE: {
                    String[] groups = splitPlainGroups(input.trim(), getPlainMessageSeparator(field));
                    pickValueFieldCsvPlainField(fieldSB, groups, ident, field);
                    break;
                }

                default:
                    // TODO dump oneof data
                    break;
            }

            return true;
        }
    }

    private boolean pickValueFieldCsvPlainField(StringBuffer fieldSB, String[] inputs, IdentifyDescriptor ident,
            DataDstFieldDescriptor field) throws ConvException {
        if (field.getTypeDescriptor() == null || ident == null || inputs == null || inputs.length == 0) {
            return false;
        }

        ArrayList<DataDstFieldDescriptor> children = field.getTypeDescriptor().getSortedFields();
        if (children.size() != inputs.length) {
            throw new ConvException(
                    String.format("Try to convert %s to %s failed, field count not matched(expect %d, real %d).",
                            field.getTypeDescriptor().getFullName(), field.getTypeDescriptor().getFullName(),
                            children.size(), inputs.length));
        }

        fieldSB.append("(");
        for (int i = 0; i < inputs.length; ++i) {
            if (i != 0) {
                fieldSB.append(",");
            }
            String varName = getIdentName(children.get(i).getName());
            fieldSB.append(varName);
            fieldSB.append("=");
            pickValueFieldPlainCsvImpl(fieldSB, ident, children.get(i), false, inputs[i]);
        }

        // TODO dump oneof data
        // for (DataDstOneofDescriptor oneof :
        // field.getTypeDescriptor().getSortedOneofs()) {
        // }

        fieldSB.append(")");
        return true;
    }

    protected boolean pickValueMessageCsvDefaultImpl(StringBuffer sb, DataDstMessageDescriptor fd) {
        if (fd == null) {
            return false;
        }

        switch (fd.getType()) {
            case INT:
            case LONG:
            case FLOAT:
            case DOUBLE: {
                sb.append("0");
                break;
            }
            case BOOLEAN: {
                sb.append("False");
                break;
            }
            case STRING:
            case BYTES: {
                return false;
            }
            case MESSAGE: {
                sb.append("(");

                boolean isFirstField = true;
                for (DataDstFieldDescriptor subField : fd.getSortedFields()) {
                    if (isFirstField) {
                        isFirstField = false;
                    } else {
                        sb.append(",");
                    }

                    sb.append(getIdentName(subField.getName()));
                    sb.append("=");
                    if (subField.isList()) {
                        sb.append("()");
                    } else if (subField.getType() == JAVA_TYPE.STRING || subField.getType() == JAVA_TYPE.BYTES) {
                        sb.append("\"\"");
                    } else {
                        pickValueFieldCsvDefaultImpl(sb, subField);
                    }
                }

                // TODO dump oneof data
                // for (DataDstOneofDescriptor oneof :
                // fd.getSortedOneofs()) {
                // }

                sb.append(")");
                break;
            }
            default:
                // TODO dump oneof data
                return false;
        }

        return true;
    }

    protected boolean pickValueFieldCsvDefaultImpl(StringBuffer sb, DataDstFieldDescriptor fd) {
        if (fd.isList()) {
            sb.append("()");
            return true;
        }

        return pickValueMessageCsvDefaultImpl(sb, fd.getTypeDescriptor());
    }
}
