package org.xresloader.core.data.dst;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.xresloader.core.ProgramOptions;
import org.xresloader.core.data.dst.DataDstWriterNode.DataDstFieldDescriptor;
import org.xresloader.core.data.dst.DataDstWriterNode.JAVA_TYPE;
import org.xresloader.core.data.err.ConvException;
import org.xresloader.core.data.src.DataSrcImpl;
import org.xresloader.core.scheme.SchemeConf;

/**
 * Created by owentou on 2019/04/08.
 */
public class DataDstUECsv extends DataDstUEBase {
    /**
     * @return 协议处理器名字
     */
    public String name() {
        return "ue csv";
    }

    public void appendCommonHeader(CSVPrinter sp) throws IOException {
        sp.printComment("This file is generated by xresloader, please don't edit it.");
    }

    private class UEBuildObject {
        StringBuffer sb = null;
        CSVPrinter csv = null;
    }

    @Override
    protected boolean isRecursiveEnabled() {
        return false;
    }

    @Override
    protected Object buildForUEOnInit() throws IOException {
        UEBuildObject ret = new UEBuildObject();
        ret.sb = new StringBuffer();
        ret.csv = new CSVPrinter(ret.sb, CSVFormat.EXCEL);

        appendCommonHeader(ret.csv);
        ret.csv.printComment(String.format("%s=%s", "xres_ver", ProgramOptions.getInstance().getVersion()));
        ret.csv.printComment(String.format("%s=%s", "data_ver", ProgramOptions.getInstance().getDataVersion()));
        ret.csv.printComment(String.format("%s=%d", "count", DataSrcImpl.getOurInstance().getRecordNumber()));
        ret.csv.printComment(String.format("%s=%s", "hash_code", "no hash code"));

        return ret;
    }

    @SuppressWarnings("unchecked")
    @Override
    protected byte[] buildForUEOnFinal(Object buildObj) {
        // 带编码的输出
        String encoding = SchemeConf.getInstance().getKey().getEncoding();
        if (null == encoding || encoding.isEmpty())
            return ((UEBuildObject) buildObj).sb.toString().getBytes();

        return ((UEBuildObject) buildObj).sb.toString().getBytes(Charset.forName(encoding));
    }

    @SuppressWarnings("unchecked")
    @Override
    protected void buildForUEOnPrintHeader(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException {
        if (isRecursiveEnabled()) {
            ((UEBuildObject) buildObj).csv.printRecord(rowData);
        }
    }

    @SuppressWarnings("unchecked")
    @Override
    protected void buildForUEOnPrintRecord(Object buildObj, ArrayList<Object> rowData, UEDataRowRule rule,
            UECodeInfo codeInfo) throws IOException {
        ((UEBuildObject) buildObj).csv.printRecord(rowData);
    }

    @Override
    public DataDstWriterNode compile() {
        ProgramOptions.getLoger().error("UE-CSV can not be protocol description.");
        return null;
    }

    @SuppressWarnings("unchecked")
    private void writeConstData(CSVPrinter sp, Object data, String prefix) throws IOException {
        // null
        if (null == data) {
            sp.printRecord(prefix, "");
            return;
        }

        // 数字
        // 枚举值已被转为Java Long，会在这里执行
        if (data instanceof Number) {
            sp.printRecord(prefix, data);
            return;
        }

        // 布尔
        if (data instanceof Boolean) {
            sp.printRecord(prefix, ((Boolean) data) ? 1 : 0);
            return;
        }

        // 字符串&二进制
        if (data instanceof String) {
            sp.printRecord(prefix, data);
            return;
        }

        // 列表
        if (data instanceof List) {
            List<Object> ls = (List<Object>) data;
            for (int i = 0; i < ls.size(); ++i) {
                if (prefix.isEmpty()) {
                    writeConstData(sp, ls.get(i), String.format("%d", i));
                } else {
                    writeConstData(sp, ls.get(i), String.format("%s.%d", prefix, i));
                }
            }
            return;
        }

        // Hashmap
        if (data instanceof Map) {
            Map<String, Object> mp = (Map<String, Object>) data;
            for (Map.Entry<String, Object> item : mp.entrySet()) {
                if (prefix.isEmpty()) {
                    writeConstData(sp, item.getValue(), String.format("%s", item.getKey()));
                } else {
                    writeConstData(sp, item.getValue(), String.format("%s.%s", prefix, item.getKey()));
                }
            }
            return;
        }

        ProgramOptions.getLoger().error("rewrite %s as nil, should not called here.", data.toString());
    }

    /**
     * 和输出格式无关的常量转储功能
     * 
     * @param data 常量数据集
     * @return 常量代码
     */
    @Override
    public String dumpConstForUE(HashMap<String, Object> data, UEDataRowRule rule) throws IOException {
        StringBuffer sb = new StringBuffer();
        CSVPrinter csv = new CSVPrinter(sb, CSVFormat.EXCEL.withHeader(getIdentName("Name"), getIdentName("Value")));

        appendCommonHeader(csv);
        writeConstData(csv, data, "");

        return sb.toString();
    }

    @Override
    final protected Object pickValueField(DataDstWriterNodeWrapper desc) throws ConvException {
        if (!isRecursiveEnabled()) {
            return pickValueFieldBaseImpl(desc, 0);
        }

        return pickValueFieldCsvImpl(desc);
    }

    protected Object pickValueFieldCsvImpl(DataDstWriterNodeWrapper descWrapper) throws ConvException {
        if (null == descWrapper || null == descWrapper.descs || descWrapper.descs.isEmpty()) {
            return null;
        }

        DataDstWriterNode desc = descWrapper.GetWriterNode(0);
        if (desc == null) {
            return null;
        }

        if (descWrapper.isList) {
            JSONArray ret = new JSONArray();
            for (DataDstWriterNode child : descWrapper.descs) {
                Object val = pickValueFieldJsonImpl(child);
                if (val != null) {
                    ret.put(val);
                }
            }

            return ret;
        } else {
            return pickValueFieldJsonImpl(desc);
        }
    }

    protected Object pickValueFieldCsvImpl(DataDstWriterNode desc) throws ConvException {
        if (desc == null) {
            return null;
        }

        if (desc.getType() == JAVA_TYPE.MESSAGE) {
            HashSet<String> dumpedFields = null;
            if (isRecursiveEnabled()) {
                dumpedFields = new HashSet<String>();
            }

            JSONObject ret = new JSONObject();
            for (Entry<String, DataDstChildrenNode> child : desc.getChildren().entrySet()) {
                Object val = null;
                if (child.getValue().innerDesc.isList()) {
                    JSONArray res = new JSONArray();

                    for (DataDstWriterNode subNode : child.getValue().nodes) {
                        Object v = pickValueFieldJsonImpl(subNode);
                        if (v != null) {
                            res.put(v);
                        }
                    }

                    val = res;
                } else if (!child.getValue().nodes.isEmpty()) {
                    val = pickValueFieldJsonImpl(child.getValue().nodes.get(0));
                }

                if (val != null) {
                    String varName = getIdentName(child.getKey());
                    ret.put(varName, val);

                    if (null != dumpedFields) {
                        dumpedFields.add(varName);
                    }
                }
            }

            // 需要补全空字段
            if (null != dumpedFields) {
                for (HashMap.Entry<String, DataDstFieldDescriptor> varPair : desc.getTypeDescriptor().fields
                        .entrySet()) {
                    String varName = getIdentName(varPair.getKey());
                    if (dumpedFields.contains(varName)) {
                        continue;
                    }

                    ret.put(varName, pickValueFieldCsvDefaultImpl(varPair.getValue()));
                }
            }

            return ret;
        }

        return pickValueFieldBaseImpl(desc);
    }

    protected void pickValueFieldCsvDefaultImpl(StringBuffer sb, DataDstFieldDescriptor fd) {
        if (fd.isList()) {
            return;
        }

        switch (fd.getType()) {
        case INT:
        case LONG:
        case FLOAT:
        case DOUBLE: {
            sb.append("0");
        }
        case BOOLEAN: {
            sb.append("false");
        }
        case STRING:
        case BYTES: {
            break;
        }
        case MESSAGE: {
            sb.append("(");

            for (HashMap.Entry<String, DataDstFieldDescriptor> varPair : fd.getTypeDescriptor().fields.entrySet()) {
                sb.append("getIdentName(varPair.getKey())");
                sb.append("=");
                if (varPair.getValue().isList() || varPair.getValue().getType() == JAVA_TYPE.STRING) {
                    sb.append("\"\"");
                } else {
                    pickValueFieldCsvDefaultImpl(sb, varPair.getValue());
                }
            }

            sb.append(")");
        }
        default:
            break;
        }
    }
}
